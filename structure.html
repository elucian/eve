<html><head>
  <meta charset="utf-8">
  <meta name="description" content="Sage-Code EVE projectâ€ž structure.">
  <meta name="author" content="Elucian Moise">
  <meta name="keywords" content="sage, code, EVE, project, language">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Website title -->
  <title>EVE Structure</title>

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
  <!-- Icon -->
  <link rel="icon" type="image/png"  href="../images/favicon.ico">
  <!-- EVE code highlighter -->
  <script src="eve.js"></script>
  <!-- Sage-Code custom CSS -->
  <link rel="stylesheet" href="../sage.css">
  </head>
<body onload="eve_render();">

<div class="container">

<!-- header -->
<div class="row">
    <div class="col">
        <a href="https://sagecode.net"><img src="../images/sage-logo.svg" alt="Sage-Code Laboratory" height="80"/></a>
    </div>
    <div class="col  bottom-right">
        <a href="index.html#lang-index">index</a><--
    </div>
</div><hr>

<h1>EVE Structure</h1>

<div class="alert alert-secondary shadow-sm">
EVE is a scripting language designed to quicly build an automation program that can be managed by a job schedule. Usually you do all the job in one script but sometimes you need to divide a project into parts. Therefore EVE has support for secondary scripts. The main script together with secondary scripts and library modules are stored in a folder structure we will explain below. </div>

<h2>Structure</h2>

<p>Next sections will teach you the structure of EVE projects.</p>

<p><b>Bookmarks:</b></p>
<ul>
<li><a href="#modules">Scripts</a></li>
<li><a href="#modules">Modules</a></li>
<li><a href="#aspects">Aspects</a></li>
<li><a href="#drivers">Drivers</a></li>
<li><a href="#regions">Regions</a></li>
<li><a href="#global">Globals</a></li>
<li><a href="#classes">Classes</a></li>
<li><a href="#functions">Functions</a></li>
<li><a href="#routines">Routines</a></li>
<li><a href="#local">local</a></li>
<li><a href="#execution">Execution</a></li>
</ul>

<h2><a id="scripts">EVE script</h2>

<p>EVE enable you to create scripts that can be compiled in memory and can be run in a loop until a finalization condition force the program to terminate. EVE scripts are never compiled into an executable form. Every time a script runs, it create a log file that can be archived and investigate later.<p>

<ul>
<li>EVE scripts have extension *.eve,</li>
<li>EVE scripts can compile in memory and can call each other,</li>
<li>EVE scripts can ve scheduled to run at specified time.</li>
</ul>

<h4>Kind of Scirpts</h4>

<p>EVE include several kind of scripts that together makes a "suite" of scripts, called project. Some scripts are reusable to many projects but some are specific to a single project. Here are all the possible scripts:</p>

<ul>
<li>Module script, created with keyword: "module",</li>
<li>Aspect script, created with keyword: "aspect",</li>
<li>Driver script, created with keyword: "driver",</li>
</ul>

<p><b>Notes:&nbsp;</b>One project can contain one or many "driver scripts". A driver script can "import modules". A module is a non executable script that contains utility: constants, data types, functions, and routines. </p>

<h4>Restrictions</h4>

<ul>
<li>A module can not import a driver or an aspect script;</li>
<li>A module can be imported but can not be resolved;</li>
<li>A driver can <em>resolve</em> multiple aspects but can not resolve a driver;</li>
<li>An aspect can <em>resolve</em> other aspects but can not resolve itself or a driver.</li>
</ul>

<h2><a id="modules"></a>Modules</h2>
<p>Modules are source files having extension: *.eve. Module names are using lowercase letters, can contain underscore or digits but no special characters and no Unicode strings. Longer names that use several words can be separate with underscore. The module name can be 30 characters long.</p>

<h4>Members</h4>
<ul>
<li>public member identifier start with "." prefix;</li>
<li>one module can use public members from other modules;</li>
<li>one module can have public member used in other modules;</li>
<li>member identifier names can be 30 characters long;</li>
</ul>

<h4>Library</h4>
<p>A&nbsp;<em>library</em>&nbsp;is a shared folder containing reusable modules.</p>
<ul>
<li>library contain generic functionality and can be shared between multiple projects;</li>
<li>using import several modules can be loaded from a folder at once;</li>
<li>circular import is possible: run-time environment has a protection against infinite recursion;</li>
<li>after import you can call public members of a library using&nbsp;<em>dot notation</em>;</li>
</ul>

<h2><a id="aspects">Aspects</h2>

<p>An <em>"aspect"</em> is a script specific to a particular project. It resolve one aspect of a problem. Aspect files are executable scripts. You can call one aspect from another aspect or from the application driver.</p>

<p>An aspect have parameters and processing region. You can call an aspect by using keyword: "start". An aspect can fail or can pass. You can collect the aspect status to check if the aspect has pass or failed.</p>

<h2><a id="drivers">Drivers</h2>
<p>A&nbsp;<em>driver</em>&nbsp;is the application main aspect. It has the role to lead the application logical thread. When&nbsp;<em>driver</em>&nbsp;execution is over the application give control back to the operating system.</p>
<h4>Notes:</h4>
<ul>
<li>Any application must have one single driver,</li>
<li>A driver is the application entry point,</li>
<li>A driver can read configuration files at startup,</li>
<li>A driver can receive parameters as constants from a configuration file;</li>
<li>A driver can be terminated early using keywords: abort, or over; </li>
<li>A driver is independent, can not be imported in other modules or suites;</li>
<li>A driver do not have public members and methods, it is not for reuse;</li>
</ul>

<h2><a id="configuration"></a>Configuration</h2>
<p>One application can load system constants from a configuration file. These are stored as "$name:value" pairs. Some system constants can be derived from environment variables using concatenation operators "&amp;","+", "/" or "\".</p>
<p>A configuration file have extension .cfg. It can be used by the compiler or by the application. One application can run with different configuration files. Application documentation must contain description of configuration constants.</p>
<p>Sometimes a&nbsp;<em>file template</em>&nbsp;is provided for copy and modify. Template file may contain comments using Bee syntax that you will learn later. Bee application will automatically parse configuration file to read values for:&nbsp;<em>system constants</em>.</p>


<h2><a id="regions"/>Script Regions</h2>
<p>A script file is divided into regions using keywords: {import, define, global, class, routine}. In each region you can declare one or single kind of members. Executable statements are enclosed in structures.</p>

<h4>Syntax Pattern:</h4>

<p>An EVE script start with optional directive: "driver", "aspect", "module". If none is specified, then we consider the file a module. That is a module can not be executed if is not imported in a driver or aspect.</p>

<pre><code class="language-eve"># structure of a driver (pseudocode)
/**
   Header comments: module purpose
   Is using JavaDoc style for comments
*/

** declare the name and type of a module
[driver | aspect | module] demo:

** global region
global
    $sys_con = "value"; // system constant
    @sys_var = {1,2,3}; // system variable
...

** import region
import
    from $path/library_name use (*);

** qualifier suppression region
aliase
    ClassName = library_name.class_name;
    ClassName = class_name{generic_parameters};
    ...

** shared constants region
global
    TypeName NAME = value; // constant (UPPERCASE NAMES)


** function declaration region
function
    TypeName: name(params) =&gt; (expression);
    ...

** class declaration region
class ClassName(params) &lt;: Superclass:
  ...
return;

** routine declaration region
routine name(params):
  ...
return;

** local declaration region
local
    TypeName x;         // default value = 0
    TypeName y = value; // specify value &ne; 0
    ...
process
   // executable region
   ...
return;
</code></pre>


<h4>Declaration order</h4>

<p>Order of regions by default is: {global, import, aliases, constants, variables, functions, classes, routines, local, process}. Routines and classes can alternate. You can define multiple regions of the same type when members depend on each other.</p>


<h3><a id="global"></a>Globals</h3>

<p>Globals are declared in first module region, with zero space indentation. There is no keyword "global". Global members are recognized by "sigil" $ or @. Therefore we do not need any keywords to declare global:</p>

<h4>Declare Globals</h4>

<pre class="language-eve fixed">
global
    $identifier := value;
    @identifier := value;
</pre>

<p>Once you have imported one module that have global, you can access them without qualifiers. If names colide, the import can fail, you have to hide the global members that colide to be able to import.</p>

<h3>System constants</h3>

<p>System constants start with prefix "$". Usually are loaded from a configuration file (*.cfg) and do not need to be declared explicit in a&nbsp;<em>constant</em>&nbsp;region. They are known by EVE runtime environment and can be used in all modules.</p>

<h4>Note:</h4>
<ul>
<li>System constants can be defined in a configuration file</li>
<li>System constants can be defined in a drivers and modules not in aspects.</li>
</ul>
<p>Several system constants are provided by EVE environment:</p>
<ul>
<li>$eve_home :eve runtime</li>
<li>$pro_home :project home</li>
<li>$eve_lib :eve lib folder</li>
<li>$pro_lib :project lib folder</li>
</ul>

<h3>System variables</h3>
<p>System variables are starting with prefix "@" and are defined by standard library.</p>
<ul>
<li>$error :contains last error message</li>
<li>@stack :contains debug information about current call stack</li>
<li>@trace :contains reporting information about executed statements</li>
<li>@level :contains how deep is the current call stack</li>
</ul>
<h4>Notes:</h4>
<ul>
<li>User can create new system variables specific to one application;</li>
<li>Prefix "@" is used to avoid scope qualifier and improve code readability;</li>
</ul>

<h3>Import region</h3>

<p>Is used to include members from several other modules into current module:</p>
<h4>Syntax:</h4>
<pre><code class="language-eve">** define global constant
global
    $user_path := $root_path/relative_path

import
    from $user_path use (member_name,...);  // specific members
    from $user_path use (*);                // all public members
    ...
</code></pre>

<h4>Notes:</h4>
<ul>
<li>$user_path is any path defined by the user;</li>
<li>spaces in file-names are not supported you must use: "_" instead;</li>
<li>member alias can rename any member: {constants, variables, functions, routines};</li>
</ul>

<h3>Shared constants</h3>

<p>Shared constants are declared in&nbsp;<em>constant</em>&nbsp;region, with "." prefix.</p>

<h4>Example</h4>

<pre><code class="language-eve">constants
    Double .PI = 3.14; // shared constant
</code></pre>

<h4>Notes:</h4>
<ul>
<li>Constants are immutable entities, they can not be altered,</li>
<li>Constant identifiers are by convention using uppercase letters,</li>
<li>Public constants (shared constants) are using dot prefix: ".",</li>
<li>Private constants are using underscore prefix "_",</li>
<li>Constants are using operator ":=" for initialization,</li>
</ul>

<h3>Shared variables</h3>
<p>Shared variables are declared in&nbsp;<em>variable</em>&nbsp;region:</p>

<h4>Example:</h4>

<pre><code class="language-eve">#declare variables
Double pi = 3.14; //  shared variable
</code></pre>

<h4>Note:</h4>
<ul>
<li>Shared variables are static;</li>
<li>Identifiers are using lowercase letters;</li>
<li>Data type is specified before the identifier;</li>
</ul>

<h2><a id="functions">Functions</h2>

<p>A function is a relation between some input values and output values. A function may or may not make a computation to establish the output. In EVE functions are pure and first class values.</p>

<h4>Pattern:</h4>

<p>Functions are declared in script regions that start with keyword: "function". A function can be public or private, local or global. Let's analyze the syntax: </p>

<pre><code class="language-eve">#declare functions
function
    TypeName name(parameters) =&gt; (expression);
</code></pre>

<h4>Notes:</h4>

<ul>
<li>Result type is declared before function name,</li>
<li>You can declare more than one function in same region.</li>
<li>A function can have only input parameters,</li>
<li>A function can have a single expression,</li>
<li>A function can be created by a routine,</li>
<li>A routine can receive parameters of type function,</li>
</ul>

<p><b>Function call</b>&nbsp;The call for a function is using name of the function and round brackets () for arguments. The brackets are mandatory even if there are no arguments, otherwise the function is not executed.</p>

<h4>Pattern:</h4>

<pre><code class="language-eve">#demo function call
driver function_call:

function
    TypeName: function_name(Type : param = value,...) =&gt; (expression);

local
    TypeName result; //not initialized (require store)
process
    ** call with no arguments:
    result := function_name();

    ** call with arguments mapped by position
    result := function_name(value, ...);

    ** call using parameter names and pair-up operator ":"
    result := function_name(parameter:value ...);
return;
</code></pre>

<p><b>Note:</b>&nbsp;Argument value can be anything that translate to a value of expected type:</p>
<ul>
<li>value ::= constant | variable</li>
<li>value ::= expression | other function call</li>
</ul>
<p><b>formal parameters</b></p>
<ul>
<li>Parameters are declared in parenthesis () after the function name,</li>
<li>Each parameter has name and type and can have one default value,</li>
<li>When a function is called each parameter receive a value that is called argument.</li>
</ul>

<h4>function call arguments</h4>

<p>There is a difference between the parameter and the argument. The parameter is a local variable in the function scope while arguments are values assigned to these parameters with a function call. Arguments can be literals, constants or variables.</p>
<h4>Example:</h4>
<pre><code class="language-eve"># demo function with parameters
driver function_params:

function
    Integer sum(Integer a, b) =&gt; (a + b);

process
    print sum(1,2);  // 3
    print sum(2,4);  // 6
return;
</code></pre>

<h2><a id="routines"/>Routines</h2>
<p>A routine is a named block of code that can be executed multiple times. A script can have one or more routines. Driver and aspects, must have one special routine that is called "main". Driver can accept a list of text parameters. Aspect can have other type of parameters inlcuding output parameters.</p>

</p>
<ul>
<li>A routine start with keyword&nbsp;<em>routine</em>;</li>
<li>A routine has a name identifier followed by a list of parameters;</li>
<li>A routine use columns ":" after parameters to start routine body;</li>
<li>A routine can have local members defined after ":" in local scope;</li>
<li>A routine can have encapsulate an executable <em>process;</em></li>
<li>A routine can be terminated early using keyword&nbsp;<em>exit</em>;</li>
<li>A routine is ending with mandatory <em>return</em>&nbsp;statement;</li>
</ul>

<h4>Syntax Pattern:</h4>
<p>Routine with result:</p>
<pre><code class="language-eve">
aspect aspect_name(Type parameter, Type .result):
    ** global declarations
    ...
local
    ** declare local variables
    ...
process
    ** executable region
    if condition then
       exit;
    end if;
    ...
    result := value; //result parameter
return [result];
</code></pre>

<h4>Notes:</h4>
<ul>
<li>empty list () is not required when the routine does not have parameters;</li>
<li>input parameters are declared as: "type param_name" ;</li>
<li>output parameters are declared with dot prefix "." ;</li>
<li>usually a routine has side effects while a function does not;</li>
<li>routine ".result" is optional and is actually an output parameter.</li>
</ul>

<p><b>Routine name</b>&nbsp;A routine is extending the language with domain specific algorithms. It must have suggestive names so that other developers can understand its purpose. The routines are doing something, therefore the best names for methods are verbs.</p>

<p><b>Parameters</b>&nbsp;Formal parameters are defined in round brackets () separated by comma. Each parameter must have type and name. Using parameters require several conventions to resolve many requirements. General syntax for parameter name is:</p>

<h4>Syntax:</h4>

<p>Mandatory parameters do not have initial values but only type. Optional parameters have initial value.</p>

<ul>
<li>TypeName parameter </li>
<li>TypeName parameter = value </li>
</ul>

<h4>Notes:</h4>

<ol>
<li>One routine can receive one or more parameters,</li>
<li>Parameters having initial values are optional,</li>
<li>Values used for parameters in routine call are called arguments,</li>
<li>You can assign arguments by position using a list of values,</li>
<li>You can assign arguments ny name using <code>name:value</code> pairs;</li>
</ol>

<p><b>Variable list of arguments</b></p>
<p>One routine can receive multiple arguments of the same type separated by comma into a list.</p>
<ul>
<li>First arguments can be captured using named parameters,</li>
<li>The rest of arguments are captured into parameter of type List or Map named: "*args",</li>
<li>A routine can have one single parameter for varargs,</li>
<li>The list parameter name is declared using sigil: "*",</li>
<li>You can use any name instead of "*args" but this is the usual name.</li>
</ul>

<h4>Example:</h4>
<pre><code class="language-eve"># print all arguments
driver test_args:

routine test(List[String] *args)
process
  print args;
return;


local
    Set[Integer] argument;
process
** call routine with variable number of arguments
    test ('a','b','c'); // use 3 arguments
    test ('a','b');     // use 2 arguments

** you can use operator "*" to "spread" collection elements
    argument := {1, 2, 3};
    test (*argument);
return;
</code></pre>

<h4>Routine context</h4>
<p>Every routine has a local context. In this context a routine can define variables, functions and objects but not other routines nor clases. These members are private, can not be accessed from outside of the routine.</p>

<p><b>Routine call</b>&nbsp;Routines can be used in call statements. A routine call can be done using "apply routine_name" followed by arguments. For one single argument, or no argument the parentheses are not required.</p>

<pre><code class="language-eve">#these are all valid routine calls
routine_name; //call routine without arguments
routine_name argument_value;     //call with single argument
routine_name value1, value2,;    //call with multiple arguments
routine_name (value, value, ...);//call with a list of arguments
routine_name (param:value,...);  //call with a argument by name
routine_name (value, value, param:value); //mix position with names
routine_name (value, *list_args);         //mix position with list
routine_name (param:value, *map_args);    //mix names with dictionary
</code></pre>

<p><b>Routine termination</b>&nbsp;A routine end with keyword return; When routine is terminated, program execution will continue with the next statement after the routine call. Keyword <em>exit</em> can terminate a routine early. If the result do not have initial value and routine terminate early the result may be null.</p>

<h4>Example:</h4>
<pre><code class="language-eve"># driver with parameters
driver routine_call(List[String]: *args):

routine test(Integer a):
process
    ** print is a system routine
    print 'argument list has # members' ? a;
return;

local
    ** number of arguments received:
    Integer c := args.length();
process
    ** verify condition and exit
    exit if c == 0;  // early interruption
    apply test(c);   // routine call
return;
</code></pre>

<h4>Side Effects</h4>
<p>A routine can have side-effects:</p>
<ul>
<li>modify a shared variable;</li>
<li>open and write into a file;</li>
<li>print a message or accept input from console;</li>
</ul>
<p><b>using side-effects</b></p>
<p>Next routine: "add_numbers" has 2 side effects:</p>
<pre><code class="language-eve">#test side-effects
driver side_effect:

routine add_numbers():
process
    **side effects
    test := p1 + p2; //  first side-effect
    print test;      //  second side-effect
return;

** local variables
local
    Integer test;
    Integer p1;
    Integer p2;
process
    p1 := 10;    //  side effect
    p2 := 20;    //  side effect
    add_numbers; //  call routine add_numbers;
    expect (result == 30);
return;
</code></pre>

<h4>Output Parameters</h4>
<p>To avoid shared variables you can use input/output parameters. We mark ourput parameters using symbol "." like parameter is public. Output parameters require a variable as argument, otherwise you will not be able to capture the output value.</p>

<pre><code class="language-eve">#demo output parameters
driver output_params:

routine add(Integer p1 = 0, p2 = 1,  Integer .out):
process
    out := p1 + p2;
return;

local
    Integer result;
process
    ** reference argument require a variable
    apply add(1,2, result);
    print result;     //  expected value 3
    ** negative test
    apply add(1,2,4); //  error, "out" parameter require a variable
return;
</code></pre>

<h4>Notes:</h4>
<ul>
<li>Output parameters are usually the last parameters;</li>
<li>Output parameters are having "." prefix;</li>
<li>Routine calls are statements, not expressions;</li>
<li>You can not create nested routines;</li>
<li>You can not create references to routines;</li>
</ul>

<h4>Dispatch</h4>

<p>Dispatch is a form of subroutine selection by signature. It makes possible multiple subroutines with the same and different parameters. These kind of subroutines are&nbsp;<em>overloaded</em>. Subroutine signature include name, parameter types and result types.</p>

<p><b>Wikipedia:</b>&nbsp;<a href="https://en.wikipedia.org/wiki/Name_mangling" rel="nofollow">name mangling</a></p>


<h2><a id="classes"/>Classes</h2>

<p>Classes are composite data types. We use a classes to create multiple objects with same structure. Each object is a reference to a location in memory were the object is stored. An object is also called instance of a class.</p>

<h4>Pattern:</h4>

<pre><code class="language-eve">
class name(parameters) &lt;: base_class:
   // definition region
   ...
create
   // constructor region
   ...
remove
   // release region
   ...
return;
</code></pre>

<h2><a id="execution">Script Execution</h2>
<p>EVE scripts are executed using a virtual machine. You can start the virtual machine as a service or as console application. In console you can&nbsp;<em>start</em>&nbsp;only a one script at a time. In service mode you can&nbsp;<em>start</em>&nbsp;multiple sessions with different startup parameters. Each session is independent and can&nbsp;<em>start</em>&nbsp;one single script.</p>

<p><b>Configuration: &nbsp;</b>EVE services using a general configuration file: eve.cfg. This file contains information about all scripts and configuration files. After the service starts this file is parsed and each script that have an entry is start automatically forming a session. For each session, the service will create a different log file.</p>

<p><b>Memory allocation:&nbsp;</b>EVE service is in charge of allocating memory for one session before the application starts. There is no shared memory between sessions. That is a session is dedicated for a single application. After application is terminated the memory is released.</p>

<p>To start an application there are 2 methods:</p>
<ol>
<li>Using the system command call with parameters</li>
<li>Using console REPL commands line app and type a "start" command</li>
</ol>

<h4>Running a Driver</h4>

<pre class="language-eve">eve:&gt; run path/driver_name -c file.cfg -m 2048GB</pre>

<h3>Driver Execution:</h3>
<p>When a driver is executed, all it's components are compiled in memory, then the <em>main subroutine</em> is executed. If a script do not have a "main()", it can not be executed. The is the program entry point. When the "driver.main()" is finalized the program terminates and is removed from memory.</p>

<h3>Aspect Execution:</h3>
<p>One aspect is executed from "driver main process" or from another aspect process. You can not start an aspect from itself. Recursive or cyclic aspects are not supported. The compiler will detect a recursive aspect and will fail.</p>

<h4>Synchronously</h4>

<p>Aspects can be resolved in linear mode one after another. Let's consider we have 3 aspect modules: aspect_a, aspect_b, aspect_c. We can execute each aspect using keyword: "solve". This will start aspect in synchronous mode and wait for each aspect to finish before start the next aspect:</p>

<pre><code class="language-eve">** resolve several aspects
routine sync_demo:
process
    ** solve each aspect immediately
    solve aspect_a(params);
    solve aspect_b(params);
    solve aspect_c(params);
    ...
return;
</code></pre>

<h4>Asynchronously</h4>

<p>Aspects can be resolved in parallel mode in different processes.</p>

<pre><code class="language-eve">** resolve several aspects
routine async_demo:
process
    ** enqueue aspects to be resolved
    begin aspect_a(params);
    begin aspect_b(params);
    begin aspect_c(params);
    ** wait for enqueued aspects to finish
    rest;
return;
</code></pre>

<h4>Parallel Sessions</h4>

<p>One aspect can resolve same problem with different parameters in parallel.</p>

<pre><code class="language-eve">** resolve several aspects
driver begin_demo:

process
    ** enqueue same aspect 4 times
    for i in (1..4) loop
        begin aspect_demo(i);
    end loop;
    rest;
return;</code>
</pre>


<h3>Module Execution:</h3>

<p>The drivers and aspects can load modules in memory. After loading, all public elements of modules can be executed on demand. Before execution the driver can interact with the user to ask for input then call routines, functions and static classes members.</p>

<p>Modules are "singleton" once a module is loaded in memory, it will not load a second time. Its states are unique for a session. EVE is a multi-session system. A script can be run asynchronously in parallel with itself but in different sessions.</p>


<h3>Exclusive Mode:</h3>

<p>When a script is executed, it can be started with parameter: -e or --exclusive. This is a signal that the script can not be started a second time in a separated session. In this mode a script can connect to a database in admin mode and can lock a file so that no other process will access the file in parallel.</p>

<h2>Session Termination:</h2>

<p>Script termination can be done using: <em>"exit"</em> or <em>"abort"</em>. This is a way to release all locked resources and terminate the application session. Program can end with an error code using "abort N" statement, otherwise it will automatically return 0 code for the operating system.</p>

<p>When script is terminated, it depends if was started from a console in debug mode or in regular mode. In debug mode the script remains in memory, parsed and ready for debugging. The memory can be investigated using commands.</p>

<h4>Example:</h4>

<p>Next code sequence is terminated after 100 iterations:</p>

<pre><code class="language-eve">** fast forward demo
driver over_demo:

local
    Integer i = 0;
process
    loop:
        write ".";
        wait 100;
        over if i == 100;
        i += 1;
    end loop;
return;
</code></pre>

<!-- work in progress-->

<hr>
<p><b>Read next:</b>
<a href="types.html">Data Types</a></p>

<!-- Footer -->
<footer class="footer">
  <div class="footer-copyright text-center"></div>
</footer>
</div>
</body>
</html>