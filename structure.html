<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta name="demoduleion" content="Sage-Code Eve projectâ€ž structure.">
  <meta name="author" content="Elucian Moise">
  <meta name="keywords" content="sage, code, EVE, project, language">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Website title -->
  <title>Eve Structure</title>

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
  <!-- Icon -->
  <link rel="icon" type="image/png"  href="../images/favicon.ico">
  <!-- Eve code highlighter -->
  <script src="eve.js"></script>
  <!-- Sage-Code custom CSS -->
  <link rel="stylesheet" href="../sage.css">
  </head>
<body onload="eve_render()">

<div class="container">

<!-- header -->
<div class="row">
    <div class="col">
        <a href="https://sagecode.net">
          <img src="../images/sage-logo.svg" alt="Sage-Code Laboratory" height="80">
        </a>
    </div>
    <div class="col  bottom-right">
        <a href="index.html#lang-index">index</a>&lt;--
    </div>
</div><hr>

<h1>Eve Structure</h1>

<div class="alert alert-secondary shadow-sm">
Eve is designed to quickly build a data processing app that can run several jobs in order on a precise schedule. You can create one module app but sometimes you need to divide a project into many small modules that run together.</div>

<h4>Bookmarks:</h4>

<p>Next topics describe overal structure of Eve applications.</p>

<hr>

<ul>
<li><a href="#configuration">Configuration</a></li>
<li><a href="#modules">Modules</a></li>
<li><a href="#scripts">Scripts</a></li>
<li><a href="#library">Library</a></li>
<li><a href="#regions">Regions</a></li>
<li><a href="#drivers">Drivers</a></li>
<li><a href="#aspects">Aspects</a></li>
<li><a href="#execution">Execution</a></li>
</ul>
<hr>

<h2><a id="configuration"></a>Configuration</h2>

<p>EVE virtual machine can load system environment variables from a configuration file. These are stored as "$name:value" pairs. Some system constants can be derived from environment variables using concatenation operators "+", "/" or "\".</p>

<p>A configuration file have extension .cfg. One application can run with different configuration file. Application documentation must contain demoduleion of all variables required by the application.</p>

<p>A good practice is to provide a configuration &nbsp;<em>template</em>&nbsp;. The template file may contain comments using Eve syntax that you will learn later. Eve application will automatically parse configuration file to read values for:&nbsp;<em>system variables</em>.</p>

<h2><a id="modules"></a>Modules</h2>

<p>Eve modules are abstract concepts. One module exist in a folder. A module consist of several scripts with extension ".eve". Modules can be combined together in large projects. Some modules are common for many projects. These are called system modules or library modules.</p>

<p>modules ...</p>
<ul>
<li>exist in a folder,</li>
<li>consist of *.eve scripts,</li>
<li>can use each other,</li>
<li>belong to one or more projects.</li>
</ul>


<p><b>Notes: </b>Modules are folders that consist of one or more scripts. Module names are using lowercase letters, can contain underscore or digits but no special characters and no Unicode strings. Longer names that use several words can be separate with underscore. The module name can be 30 characters long. Module name is same or different than the script name that belong to a module. A module can be a single file.</p>

<h2><a id="scripts"></a>Scripts</h2>

<p>Eve define several kind of scripts that together makes a "suite", called project. Some scripts are reusable for many projects but some are specific to a single project. Here are all the possible scripts:</p>

<ul>
<li>Driver, created with keyword: "driver",</li>    
<li>Aspect, created with keyword: "aspect",</li>
<li>Module, created with keyword: "module",</li>
</ul>

<p><b>Notes:&nbsp;</b>One project can contain one or many drivers. Each driver is an independend script. A driver has a single executable process. Eve virtual machine can start multiple drivers on demand. A driver can "import" modules and can "resolve" several aspects.</p>

<h4>Restrictions</h4>

<ul>
<li>A module can not import a driver;</li>
<li>A module can not import an aspect;</li>
<li>A driver can not import an aspect;</li>  
<li>A module can be imported but can not be executed;</li>
<li>A driver can <em>resolve</em> multiple aspects;</li>
<li>A driver can <em>execute</em> aspects in parallel;</li>
</ul>

<h2><a id="regions"></a>Regions</h2>

<p>A script file is divided into regions using keywords: {import, alias, lambda, process}. Regions are using indentation. A region ends when next region starts. Eve try to be flat as much as possible. Therefore these regions do not use any indentation.</p>

<h4>Syntax Pattern:</h4>

<p>An Eve script start with one of 3 keywords: {"driver", "aspect", "module"}. Script name is the same as the file name without the extension. A script can have parameters, defined after script name in a list. A module do not have parameters.</p>

<pre><code class="language-eve">
+--------------------------------------------
 Header comments: explain the module purpose  
 These comments can be used on top of module      
---------------------------------------------+

** declare the name and type of a module
[driver | aspect | module] [parameters]:

** set system variables
  set $sys_con    = value;
  ...

** import region
import
  from $path/library_name use (*);

** qualifier suppression region
alias
  AliasName1 = library_name.MemberName;
  AliasName2 = ClassName[parameters];
  ...

** define user types
class
  NewType  = {} &lt;: Type;
  ...
** define functions using lambda expressions
lambda
  new .public_lambda   = (params) => (expression);
  new  private_lambda  = (params) => (expression);
  ...

** global & shared states
global
  set local = value1: user_tupe;
  set $name = value2: TypeName;
  ...

** main process, (executable region)
process [main]:
  new my_var  = value;  -- private variable
  ...
return;
</code></pre>


<h4>Members</h4>
<ul>
<li>a script can define: classes, expressions and functions;</li>
<li>a script can import public members from modules;</li>
<li>modules and drivers can set shared states using "$" sigil;</li>
<li>drivers and aspects are encapsulated. States are private;</li>
<li>all public members start with dot (.) proefix;</li>
</ul>

<p><b>Note: </b>Any script has one or more <em>global</em> regions. In this regions, you can define private & shared states. In declaration region you can also define: lambdas, classes & functions. Variables defined in global scope are static. You must use keyword "set" to define them and assign initial value. Static variables are created on the heap and have a permanent nature.</p>

<h3>System variables</h3>

<p><em>Shared variables </em>start with prefix "$". Usually are loaded from a configuration file (*.cfg), but sometimes are defiand explicit usually in Eve modules. Shared variables can be defined in first region with keyword "set" and indentation. No need to use <em>global</em> keyword for first region.</p>

<h4>Note:</h4>
<ul>
<li>System variables can be defined in a configuration file,</li>
<li>System variables are usually defined in core modules.</li>
</ul>

<p>Several system variables are provided by Eve environment:</p>
<ul>
<li>$eve_home :eve runtime</li>
<li>$pro_home :project home</li>
<li>$eve_lib  :eve lib folder</li>
<li>$pro_lib  :project lib folder</li>
</ul>

<p><em>System objects</em> are instantiated at startup and are part of core library. These hold runtime information that you can use for debuging. System objects do not need module qualifier. You can access them directly once the module is imported.</p>

<ul>
<li>$error :contains last error with code & message</li>
<li>$stack :contains debug information about current call stack</li>
<li>$trace :contains reporting information about executed statements
</ul>

<h4>Notes:</h4>
<ul>
<li>User can create new system variables for one application in the driver;</li>
<li>Prefix "$" is used to avoid scope/module qualifier;</li>
<li>OS System variables are constant in EVE and can't be modified;</li>
<li>System constants are capitalized and also start with "$";</li>
</ul>

<h3>Private states</h3>

<p>Private states are static variable defined in&nbsp;<em>global scope</em>&nbsp;. An aspect can not have public states. You can access private states in functions and methods without qualifier.</p>

<p>Constant names and system states start with sigil $. Constants have at least first letter capitalized. The best practice is to use all capital letters. The next symbols in a constant name can be numbers or underscore but no special or Unicode character.</p>

<h4>Example</h4>

<pre><code class="language-eve">
** gobal scope
global
  set $PI  = 3.14 :Float;      -- shared constant
  set $var = 0    :Integer;    -- shared variable
</code></pre>

<h4>Notes:</h4>
<ul>
<li>Variables/constants are using operator "=" for initialization,</li>
<li>Constants are by convention using uppercase letters,</li>
</ul>


<h4>Example</h4>

<pre><code class="language-eve">
driver test():

** private class
class Person = {name:String, age:Integer} &lt;: Object;

** create states using type inference
global
  set  $E    := 2.52; -- Euler's number (public constant)
  set   x    := 0;    -- Integer, private state

** create a global object of type Person.
process
  new  me   := Person("Elucian", "56"); 
return;
</code></pre>

<p><b>Restriction: </b>It is forbitten to use keyword "new" in global scope. All states should be created using keyword "set". A global state is bound to the current scope.</p>

<h3>Import region</h3>

<p>Te import is used to include public members from several modules into current script:</p>

<h4>Syntax:</h4>
<pre><code class="language-eve">
module name:
  ** define global states
  set $user_path := $root_path/relative_path;

  ** define public function
  function .function_name(arguments):
     ...
  return
import
  from $user_path use (module_name,...);  -- specific modules
  from $user_path use (*);                -- find all modules
  ...
alias
  ** create alias for a member with qualifier
  set new_name := module_name.member_name;
  ...
return;
</code></pre>

<h4>Notes:</h4>
<ul>
<li>$user_path is a library path defined by the user;</li>
<li>spaces in file-names are not supported you must use: "_";</li>
<li>aliases are created from public members of other module;</li>
</ul>

<h2><a id="library"></a>Library</h2>

<p>A&nbsp;<em>library</em>&nbsp;is a set of reusable modules. A library can be installed in EVE environment or can be a project specific library. EVE machine is using a special system variable to search for a library: $EVE_LIB. If the library is not found the module can't be imported and the script fails.</p>

<ul>
<li>library contain generic functionality and can be shared between multiple projects;</li>
<li>using import, several modules can be loaded from a folder at once;</li>
<li>circular import is possible, but EVE prevent infinite recursive reference;</li>
<li>after import you can call public members of a module using&nbsp;<em>dot notation</em>;</li>
<li>system variables or states that start with "$" do not need module qualifier</li>
</ul>

<p><b>Note: </b>Library name is the name of the subfolder. Module is the name of the last folder in a path. By convention you can create itermediate subfolders but only the last folder is relevant and it must be unique in a library.<p>

<h2><a id="drivers"></a>Drivers</h2>

<p>A&nbsp;<em>driver</em>&nbsp;represents the application main script. It has the role to lead the application main process. When&nbsp;<em>driver</em>&nbsp;execution is over the application give control back to the EVE virtual machine. If no other process is running, the machine shuts-down after it clean-up the memory of garbage.</p>

<h4>Notes:</h4>
<ul>
<li>Any application can have one or more drivers,</li>
<li>A driver is the process entry point,</li>
<li>A driver can read configuration files at startup,</li>
<li>A driver can receive parameters;</li>
<li>A driver can have one single main process;</li>
<li>A driver is independent, can not be imported;</li>
<li>A driver has private states and shared states;</li>
</ul>


<h2><a id="aspects"></a>Aspects</h2>

<p>An <em>"aspect"</em> is a script specific to a particular project. It resolve a problem or address a specific concern. Aspect files are executable. One aspect can execute other aspects, however it can't be recursive.</p>

<p>An aspect can receive parameters. One aspect has a declaration region and an executable region. You can resolve an aspect by using keyword: "apply" or "begin". An aspect must handle it's own errors. If errors are not handled, the program panic and stop execution.</p>

<h4>Syntax Pattern:</h4>

<pre><code class="language-eve">
aspect name(parameter_list):
  ** declare variables
  ...
process
  ** executable region
  ...
recover
  ** handle all errors
  ...
return;
</code></pre>

<p><b>Parameters</b>&nbsp; are defined in round brackets () separated by comma. Each parameter must have type and name. Using parameters require several conventions:</p>

<h4>Syntax:</h4>

<p>Mandatory parameters do not have initial values but only type. Optional parameters have initial value that is assign using operator "=" with explicit :type, or ":=" with type inference. Not both.</p>

<ul>
<li>parameter :Type</li>
<li>parameter  = value :Type</li>
<li>parameter := expression</li>
</ul>

<h4>Notes:</h4>

<ol>
<li>One aspect can receive one or more parameters,</li>
<li>Parameters having initial values are optional,</li>
<li>Values used for parameters are called "arguments",</li>
<li>You can assign arguments by position using a list of values,</li>
<li>You can assign arguments by name using <code>(name:value)</code> pairs;</li>
</ol>

<p><b>Vararg parameters</b></p>
<p>One aspect can receive multiple arguments of the same type into a special parameter. This can be any list, data set or hash map, depending on declaration.</p>

<ul>
<li>First arguments can be captured using named parameters,</li>
<li>The rest of arguments are captured into vararg parameter,</li>
<li>An aspect can have one single vararg parameter,</li>
<li>The vararg parameter name is declared using prefix: "*",</li>
<li>You can use any name but "*args" is the usual name for it.</li>
</ul>

<h4>Example:</h4>
<pre><code class="language-eve"># print all arguments
aspect test(*args: ()String):

** list all arguments
process
  cycle:
    new arg :String;
  for arg in args loop
    print arg;
  repeat;
return;
</code></pre>

<h4>Process context</h4>

<p>One script can have one single process. Every process has a local context. In this context you can define local variables, lambda expressions and objects but not classes, methods or functions. Process local members can't be shared but can be send as input/output parameters to other subprograms.</p>

<h4>Output Parameters</h4>
<p>To avoid overusing of global variables you must use input/output parameters. We mark output parameters using symbol "@". Output parameters require a variable as argument, otherwise you will not be able to capture the output value.</p>

<pre><code class="language-eve">
#demo output parameters
driver output_params:

** private method
function add(p1 = 0, p2 = 1: Integer, @op: Integer):
  let op := p1 + p2;
return;

process 
  new result: Integer;

  ** inpur/output argument require a variable
  add (1,2, op:result);
  print result;     -- expected value 3

  ** negative test, will fail
  add (1,2,4); -- error, "out" parameter require a variable
return;
</code></pre>
 
<h4>Notes:</h4>
<ul>
<li>Output parameters are usually the last parameters;</li>
<li>Output parameters are having "@" prefix;</li>
<li>Function invocation is a statement, do not need a keyword;</li>
</ul>

<h2><a id="execution"></a>Script Execution</h2>

<p>Eve scripts are executed using a virtual machine. You can start the virtual machine as a service or as console application. In console you can&nbsp;<em>start</em>&nbsp;only a one driver script at a time. In service mode you can&nbsp;<em>start</em>&nbsp;multiple drivers. Each driver is independent and can't communicate with other drivers.</p>

<p><b>Configuration: &nbsp;</b>Eve services using a general configuration file: eve.cfg. This file contains default settings for EVE machine. System variables are shared. A copy of EVE system variables is send to every new new driver. A driver can overwrite default settings.</p>

<p><b>Memory allocation:&nbsp;</b>Eve service is in charge of allocating memory for each process. There is no shared memory between processes. When a process is terminated the memory is cleaned up of garbage and the machine continue to run until all processes are finished.</p>

<p>To start a driver there are 2 methods:</p>
<ol>
<li>Using the eve system command with parameters,</li>
<li>Using console REPL commands with "start" command,</li>
<li>EVE virtual machine can be run as a daemon,</li>
<li>You can control EVE virtual machine using command: eve with parameters</li>
</ol>

<h4>Running a Driver</h4>

<pre class="language-out">eve:&gt; run ~/path/driver_name.eve -c file.cfg -m 2048GB</pre>

<h3>Driver Execution:</h3>
<p>When a driver is executed, all it's components are compiled in memory, then the <em>process</em> is executed. If a module do not have a "process", it can not be executed. The process is the driver entry point. When the <em>driver main process</em> is finalized the program terminates and is removed from memory.</p>

<h3>Aspect Execution:</h3>
<p>One aspect is executed from driver or from another aspect. You can not start an aspect from itself. Recursive aspects are not supported. The compiler will detect a recursive aspect and will fail at runtime.</p>

<h4>Synchronously</h4>

<p>Aspects can be run in serial mode one after another. Let's consider we have 3 aspects: {one.eve, two.eve, three.eve}. We can execute each aspect using keyword: "apply". This will intrerupt the driver process and will execute aspec process one by one then return control to driver and continue the main process:</p>

<pre><code class="language-eve">
driver test_apply:

# synchronous call
process
  ** apply each aspect
  apply [folder]/one(arguments);
  apply [folder]/two(arguments);
  apply [folder]/three(arguments);
  ...
return;
</code></pre>

<p><b>Note: </b>You do not have to import an aspect into a driver but you must specify the relative path of the aspect. If the aspect is in a subfolder, you must include folder name. If the aspect is in the same location as the driver, you do not need a folder name.</p>

<h4>Asynchronously</h4>

<p>Aspects can be resolved in parallel mode using keyword "begin".</p>

<pre><code class="language-eve">
# asynchronous call demo
driver async_demo:
process
  ** enqueue aspects to be resolved
  begin one(arguments);
  begin two(arguments);
  begin three(arguments);

  ** wait for enqueued aspects to finish
  wait;
return;
</code></pre>

<h4>Parallel processes</h4>

<p>One aspect can apply one aspect with different parameters several times.</p>

<pre><code class="language-eve">
** resolve several aspects
driver begin_demo:
process
  ** enqueue same aspect 4 times
  cycle
    new i: Integer;
  for i in (1..4) loop
    begin demo(i);
  repeat;
  wait;
return;
</code></pre>

<h3>Module import:</h3>

<p>The driver or aspect can import modules. After import, all public elements of modules can be used on demand. The parent process is controling the execution logic. Modules are not directly executable and can not have a process, but its public members can be executed and classes can be instantiated.</p>

<p>Modules are "singleton" once a module is loaded in memory, it will not load a second time. Eve is a multi-session system. An aspect can be run asynchronously in parallel but module states are bound the the parent process.</p>

<h3>Exclusive start:</h3>

<p>When a module is executed, it can be started with parameter: -e or --exclusive. This is a signal that the module can not be started a second time in a separated session by the same VM. In this mode a module can connect to a database in admin mode and can lock a file so that no other process will access the file until is unlocked.</p>

<h2>Program Termination:</h2>

<p>Program can be early terminated be done using: <em>"over"</em> or <em>"panic"</em>. This is a way to release all locked resources and terminate the application. Program can end with an error code using "panic N" statement, otherwise it will automatically return 1 with panic and 0 with "over". Actually "panic 0" is equivalent to "over".</p>

<p>When drive is terminated, it depends what is heppening next. When was started from a console in debug mode the module remains in memory, parsed and ready for debugging. The memory can be investigated using commands. When driver start in regular mode, the memory is erased and the EVE machine stop running.</p>

<h4>Example:</h4>

<p>Next code sequence is terminated after 100 iterations:</p>

<pre><code class="language-eve">
# terminate a program with: over
driver test_over:
process
  cycle:
    new i = 0 : Integer;
  loop
    write "."; wait  10;
    over if i > 10;
    let   i += 1;
  repeat;
return;
</code></pre>

<!-- work in progress-->

<hr>
<p><b>Read next:</b>
<a href="types.html">Data Types</a></p>

<!-- Footer -->
<footer class="footer">
  <div class="footer-copyright text-center"></div>
</footer>
</div>
</body>
</html>