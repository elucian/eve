<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta name="demoduleion" content="Sage-Code Eve projectâ€ž structure.">
  <meta name="author" content="Elucian Moise">
  <meta name="keywords" content="sage, code, EVE, project, language">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Website title -->
  <title>Eve Structure</title>

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
  <!-- Icon -->
  <link rel="icon" type="image/png"  href="../images/favicon.ico">
  <!-- Eve code highlighter -->
  <script src="eve.js"></script>
  <!-- Sage-Code custom CSS -->
  <link rel="stylesheet" href="../sage.css">
  </head>
<body onload="eve_render()">

<div class="container">

<!-- header -->
<div class="row">
    <div class="col">
        <a href="https://sagecode.net">
          <img src="../images/sage-logo.svg" alt="Sage-Code Laboratory" height="80">
        </a>
    </div>
    <div class="col  bottom-right">
        <a href="index.html#lang-index">index</a>&lt;--
    </div>
</div><hr>

<h1>Eve Structure</h1>

<div class="alert alert-secondary shadow-sm">
Eve is designed to quickly build a data processing app that can run several jobs in order on a precise schedule. You can create one module app but sometimes you need to divide a project into many small modules that run together.</div>

<h4>Page bookmarks:</h4>

<p>Next topics describe overal structure of Eve applications.</p>

<hr>

<ul>
<li><a href="#project">Project</a></li>
<li><a href="#scripts">Scripts</a></li>
<li><a href="#regions">Regions</a></li>
<li><a href="#drivers">Drivers</a></li>
<li><a href="#aspects">Aspects</a></li>
<li><a href="#modules">Modules</a></li>
<li><a href="#library">Library</a></li>
<li><a href="#execution">Execution</a></li>
<li><a href="#configuration">Configuration</a></li>
</ul>
<hr>

<h2><a id="project" href="#project"></a>Projects</h2>
<p>A project is a folder with a specific structure. It contains one or more applications that can run independent of each other on the same computer or a group of computers.</p>

<p><b>project structure</b></p>
<p>Next project contains two applications: server/agent and show folders where you should put your code (src+lib) and documentation (doc). This is a recommendation but not a hard rule.</p>

<pre><code class="language-bee">$pro_home
project
  |-- agent
  |   |-- aspect1.bee
  |   |-- aspect2.bee
  |   ...
  |-- server
  |   |--  aspect1.bee
  |   |--- aspect2.bee
  |   ...
  |-- library
  |   |-- module1
  |   |     |-- module_script1.bee
  |   |     |-- module_script2.bee
  |   |     ...
  |   |-- module2
  |   ... 
  |       
  |-- documents
  |   |-- readme.md
  |   |-- index.html
  |   ...
  |-- agent.eve
  |-- server.eve
</code></pre>

<h2><a id="scripts"></a>Scripts</h2>

<p>Eve define several kind of scripts that together makes a "project suite". Some scripts are reusable but some are specific to a single project. Here are all the possible scripts:</p>

<ul>
<li>Driver, created with keyword: "driver",</li>    
<li>Aspect, created with keyword: "aspect",</li>
<li>Module, created with keyword: "module",</li>
</ul>

<p><b>Notes:&nbsp;</b>One project can contain one or many drivers. Each driver is an independend script. A driver has a single executable process. Eve virtual machine can run a single driver at a time but several aspects in the same time. A driver can "import" modules and can "start" several aspects in parallel.</p>

<h4>Features:</h4>

<ul>
<li>A driver can import one or more modules;</li>
<li>A driver can <em>apply</em> aspects in sequence;</li>
<li>A driver can <em>start</em> aspects in parallel;</li>
<li>An aspect can be split into multiple other aspects;</li>
<li>An aspect can import several modules;</li>
<li>Modules can share states with all other scripts.</li>
</ul>

<h3><a id="regions"></a>Regions</h3>

<p>A script file is divided into regions using keywords: {import, alias, lambda, process}. Regions members are using indentation, like Python. A region ends when next region begins. Eve try to be flat as much as possible. Therefore these regions are right side aligned.</p>

<h4>Syntax Pattern:</h4>

<p>An Eve script begins with one of these keywords: {"driver", "aspect", "module"}. Script name is the same as the file name without the extension. A driver or aspect script can have parameters, defined after script name in a list, but a module do not have parameters.</p>

<pre><code class="language-eve">
+--------------------------------------------
 Header comments: explain the module purpose  
 These comments can be used on top of module      
---------------------------------------------+
[driver | aspect | module] name(parameters):

** set system variables
  set $sys_con    = value;
  ...

** import region
import
  from $path/library_name use (*);

** qualifier suppression region
alias
  AliasName1 = library_name.MemberName;
  AliasName2 = ClassName[parameters];
  ...

** define user types
class
  NewType  = {} &lt;: Type;
  ...
** define functions using lambda expressions
lambda
  new .public_lambda   = (params) => (expression);
  new  private_lambda  = (params) => (expression);
  ...

** global & shared states
global
  set local = value1: user_tupe;
  set $name = value2: TypeName;
  ...
----------------------------------------------------
** main process, or initialization region
[process | reset]
  new my_var  = value;  -- private variable
  ...
return;
-----------------------------------------------------
/* notes: can be used at the end of the script. 
   usually the notes use C like, block comments.
*/
</code></pre>


<h4>Members</h4>
<ul>
<li>a script can define: classes, expressions and functions;</li>
<li>a script can import public members from modules;</li>
<li>a script can "set" shared states using "$" sigil;</li>
<li>scripts are encapsulated, states are private;</li>
<li>public members must be declared with dot (.) proefix;</li>
<li>restriction: only modules can define public members;</li>
</ul>

<p><b>Note: </b>Any script has one or more <em>global</em> regions. In this regions, you can define private & shared states. In declaration region you can also define: lambdas, classes & functions. All variables defined in global scope are static states. You must use keyword "set" to define them and assign initial value. Static variables are created on the heap and have a permanent nature.</p>

<h3>System variables</h3>

<p><em>Shared variables </em>use prefix "$". Usually are loaded from a configuration file (*.cfg), but sometimes are defiand explicit in Eve modules or in driver. Shared variables can be defined in first region with keyword "set" and indentation. No need to use <em>global</em> keyword for first region global.</p>

<h4>Note:</h4>
<ul>
<li>System variables can be defined in a configuration file,</li>
<li>System variables are usually defined in core modules.</li>
</ul>

<p>Several system variables are provided by Eve environment:</p>
<ul>
<li>$EVE_DIR  :eve runtime</li>
<li>$EVE_LIB  :eve lib folder</li>
<li>$MY_DIR   :program location</li>
<li>$MY_LIB   :project lib folder</li>
<li>$MY_LOG   :project log folder</li>
<li>$OS_PWD   :current working folder</li>
</ul>

<p><em>System objects</em> are instantiated at startup and are part of core library. These contain runtime information that you can use for debuging. System objects do not need module qualifier. You can access them directly once the module is imported.</p>

<ul>
<li>$error :contains last error with code & message</li>
<li>$stack :contains debug information about current call stack</li>
<li>$trace :contains reporting information about executed statements
</ul>

<p>Constants and system states use sigil $. Constants have at least first letter capitalized. The best practice is to use all capital letters. The next symbols in a constant name can be numbers or underscore but no special or Unicode character.</p>

<h4>Example</h4>

<pre><code class="language-eve">
** gobal scope
global
  set $PI  = 3.14 :Float;      -- shared constant
  set $var = 0    :Integer;    -- shared variable
</code></pre>


<h4>Notes:</h4>
<ul>
<li>You can create new system constants and variables;</li>
<li>Prefix "$" is used to avoid scope/module qualifier;</li>
<li>OS environment variables are transfered to constants;</li>
<li>System constants are capitalized and also begin with "$";</li>
</ul>

<h3>Private states</h3>

<p>Private states are static variable defined in&nbsp;<em>global scope</em>&nbsp;. You can access private states in functions and methods without qualifier.</p>

<p>Private states cam be constant or variables. Constats use capital letters while variables are using lowercase letters. First letter is important, other letters can be numbers, lowercase or uppdercase letters or undrscore.</p>


<h4>Example</h4>

<pre><code class="language-eve">
driver test():

** private class
class Person = {name:String, age:Integer} &lt;: Object;

** create states using type inference
global
  set  E = 2.52 : Real;    -- Euler's number
  set  x = 0    : Integer; -- private state

** create a global object of type Person.
process
  new  me := Person("Elucian", "56"); 
return;
</code></pre>

<h4>Notes:</h4>
<ul>
<li>All states must be created using keyword "set" </li>
<li>All global states are bound to the current scope </li>
<li>Variables/constants are using operator "=" for initialization,</li>
<li>Constants are by convention using uppercase letters,</li>
<li>In the global regions you can not use type inference,<li>
</ul>

<h3>Import region</h3>

<p>The import is used to include public members from modules:</p>

<h4>Syntax:</h4>
<pre><code class="language-eve">
driver script_name:
  ** define global states
  set $user_path := root_path/relative_path;

  ** define public function
  function .function_name(arguments):
     ...
  return
import
  from $user_path use (module_name,...);  -- specific modules
  from $user_path use (*);                -- find all modules
  ...
alias
  ** create alias for a member with qualifier
  set new_name := module_name.member_name;
process
  ...
return;
</code></pre>

<h4>Notes:</h4>
<ul>
<li>$user_path is a share variable defined by the user;</li>
<li>spaces in file-names are not supported you must use: "_";</li>
<li>aliases are created from public members of other module;</li>
</ul>

<h2><a id="library"></a>Library</h2>

<p>A&nbsp;<em>library</em>&nbsp;is a set of reusable modules. A library can be installed in EVE environment or can be project specific. EVE machine is using a special system variable to search for a library: $EVE_LIB. If the library is not found the module can't be imported and the script fails.</p>

<ul>
<li>libraries contain generic functionality and can be shared between multiple projects;</li>
<li>using import, several modules can be loaded from a folder at once;</li>
<li>circular import is possible, but EVE prevent infinite recursive reference;</li>
<li>after import you can call public members of a module using&nbsp;<em>dot notation</em>;</li>
</ul>

<p><b>Note: </b>Library name is the name of the subfolder. Module is the name of the last folder in a path. By convention you can create itermediate subfolders but only the last folder is relevant and it must be unique in a library.<p>

<h2><a id="drivers"></a>Drivers</h2>

<p>A&nbsp;<em>driver</em>&nbsp;represents the application main script. It has the role to lead the application main process. When&nbsp;<em>driver</em>&nbsp;execution is over the application give control back to the EVE virtual machine. If no other process is running, the machine shuts-down after it clean-up the memory.</p>

<h4>Notes:</h4>
<ul>
<li>Any application can have one or more drivers,</li>
<li>A driver is the process entry point,</li>
<li>A driver can read configuration files at startup,</li>
<li>A driver can receive parameters;</li>
<li>A driver can have one single main process;</li>
<li>A driver is independent, can not be imported;</li>
</ul>

<h2><a id="aspects"></a>Aspects</h2>

<p>An <em>"aspect"</em> is a script specific to a particular project. It resolve a problem or address a specific concern. Aspect files are executable. One aspect can execute other aspects, however it can't be recursive.</p>

<p>An aspect can receive parameters. One aspect has a declaration region and an executable region. You can resolve an aspect by using keyword: "apply" or "start". An aspect must handle it's own errors. If errors are not handled, the program panic and stop execution.</p>

<h4>Syntax Pattern:</h4>

<pre><code class="language-eve">
aspect aspect_name(parameter_list):
  ** declare variables
  ...
process
  ** executable region
  ...
recover
  ** handle all errors
  ...
return;
</code></pre>

<p><b>Parameters</b>&nbsp; are defined in round brackets () separated by comma. Each parameter must have type and name. Using parameters require several conventions:</p>

<h4>Syntax:</h4>

<p>Mandatory parameters do not have initial values but only type. Optional parameters have initial value that is assign using operator "=" with explicit :type, or ":=" with type inference. Not both.</p>

<ul>
<li>parameter :Type</li>
<li>parameter  = value :Type</li>
<li>parameter := expression</li>
</ul>

<h4>Notes:</h4>

<ol>
<li>One aspect can receive one or more parameters,</li>
<li>Parameters having initial values are optional,</li>
<li>Values used for parameters at runtime, are called "arguments",</li>
<li>You can assign arguments by position using a list of values,</li>
<li>You can assign arguments by name using <code>(name:value)</code> pairs;</li>
</ol>

<p><b>Vararg parameters</b></p>
<p>One aspect can receive multiple arguments of the same type into a single collection parameter. This can be a List, DataSet or HashMap, depending on declaration.</p>

<ul>
<li>First arguments can be captured using named parameters,</li>
<li>The rest of arguments are captured into vararg parameter,</li>
<li>An aspect can have one single vararg parameter,</li>
<li>The vararg parameter name is declared using prefix: "*",</li>
<li>You can use any name but "*args" is the usual name for it.</li>
</ul>

<h4>Example:</h4>
<pre><code class="language-eve"># print all arguments
aspect test(*args: ()String):

** list all arguments
process
  cycle:
    new arg :String;
  for arg in args loop
    print arg;
  repeat;
return;
</code></pre>

<h4>Process context</h4>

<p>One script can have one single process. Every process has a local context. In this context you can define local variables, lambda expressions and objects but not classes, methods or functions. Process local members can't be shared but can be send as input/output parameters to other subprograms.</p>

<h4>Output Parameters</h4>
<p>To avoid overuse of global variables you must use input/output parameters. We prefix output parameters using symbol "@". Output parameters require a variable as argument, otherwise you will not be able to capture the output value.</p>

<pre><code class="language-eve">
#demo output parameters
aspect output_params:

** private method
function add(p1 = 0, p2 = 1: Integer, @op: Integer):
  let op := p1 + p2;
return;

process 
  new result: Integer;

  ** inpur/output argument require a variable
  add (1,2, op:result);
  print result;     -- expected value 3

  ** negative test, will fail
  add (1,2,4); -- error, "out" parameter require a variable
return;
</code></pre>
 
<h4>Notes:</h4>
<ul>
<li>Output parameters are usually the last parameters;</li>
<li>Output parameters are having "@" prefix;</li>
<li>Function invocation is a statement, do not need a keyword;</li>
</ul>

<h2><a id="modules"></a>Modules</h2>

<p>Eve modules are abstract concepts. One module exist in a folder. A module consist of several scripts with extension ".eve". Modules can be combined together in large projects. Some modules are common for many projects. These are called system modules or library modules.</p>

<p>modules ...</p>
<ul>
<li>exist in a folder,</li>
<li>consist of *.eve scripts,</li>
<li>can use each other,</li>
<li>belong to one or more projects,</li>
<li>can define public members,</li>
<li>can be initialized when imported first time</li>
</ul>

<h4>Syntax Pattern:</h4>

<p>An Eve module begins with "module" keyword. Module name is the same as the last folder in a library path. A module can have an initialization region. This is executed when the module is imported for the first time.</p>

<pre><code class="language-eve">
+----------------------------------------
module name is the folder name so that
one module can have more then one script.    
----------------------------------------+
module module_name:

** shared variables
$system_variable: Type;
...

** global variables
global
   set _private_state = ...
   set .public_state  = ...

** lambda expressions
lambda
   set _private_expression = ...
   set .public_expression  = ...

** private functions
function _private_function
...

** public functions
function .public_function
...

** private classes
class _Private_Class ...;

** public classes
class .Public_Class  ...;

...

reset
** initialization region
  $system_variable := value

return;
</code></pre>

<h4>Notes:</h4>
<ul>
<li>Modules don't have parameters. You can not start a module;</li>
<li>Modules can define public members and shared states;</li>   
<li>Modules members and states can be shared with a parent process;</li>
<li>Modules run in the parent process and do not start a new process;</li>
<li>A module "reset" region is executed when module is imported;</li>
<li>Asyncrhonous processes reset the module states for every aspect.</li>
<li>Synchronous processes do not reset the shared states.</li>
</ul>

<p><b>Module names </b>are using lowercase letters, can contain underscore or digits but no special characters and no Unicode strings. Longer names that use several words can be separate with underscore. The module name can be 30 characters long.</p>

<p><b>Module scripts </b>A module can be a single file but usually represents several files. The main script has the same name as the folder name. In the main script you can define public members. In secondary scripts, you can define the private members.</p>

<h2><a id="execution"></a>Script Execution</h2>

<p>Eve scripts are executed using a virtual machine. You can start the virtual machine as a service or as console application. In console you can&nbsp;<em>run</em>&nbsp;only a one driver script at a time. In service mode you can&nbsp;<em>run</em>&nbsp;multiple drivers. Each driver is independent and can't communicate with other drivers.</p>

<p><b>Configuration: &nbsp;</b>Eve services using a general configuration file: eve.cfg. This file contains default settings for EVE machine. System variables are shared. A copy of EVE system variables is send to every new new driver. A driver can overwrite default settings.</p>

<p><b>Memory allocation:&nbsp;</b>Eve service is in charge of allocating memory for each process. There is no shared memory between processes. When a process is terminated the memory is cleaned up of garbage and the machine continue to run until all processes are finished.</p>

<p>To execute a driver there are 2 methods:</p>
<ol>
<li>Using the "eve" system command with parameters,</li>
<li>Using console REPL commands with "run" command,</li>
<li>EVE virtual machine can be run as a daemon,</li>
<li>You can control EVE virtual machine using command: eve with parameters</li>
</ol>

<h3>Driver Execution:</h3>

<p>When a driver is executed, all it's components are compiled in memory, then the <em>process</em> is executed. If a module do not have a "process", it can not be executed. The process is the driver entry point. When the <em>driver main process</em> is finalized the program terminates and is removed from memory.</p>

<h4>Running a Driver</h4>

<pre class="language-out">eve:&gt; run ~/path/driver_name.eve -c file.cfg -m 2048GB</pre>

<h3>Aspect Execution:</h3>

<p>One aspect is executed from driver or from another aspect. You can not execute an aspect from itself. Recursive aspects are not supported. The compiler will detect a recursive aspect and will fail at runtime.</p>

<h4>Synchronously</h4>

<p>Aspects can be run in serial mode one after another. Let's consider we have 3 aspects: {one.eve, two.eve, three.eve}. We can execute each aspect using keyword: "apply". This will intrerupt the driver process and will execute aspec process one by one then return control to driver and continue the main process:</p>

<pre><code class="language-eve">
driver test_apply:

# synchronous call
process
  ** apply each aspect
  apply [folder/]one(arguments);
  apply [folder/]two(arguments);
  apply [folder/]three(arguments);
  ...
return;
</code></pre>

<p><b>Note: </b>You do not have to import an aspect into a driver but you must specify the relative path of the aspect. If the aspect is in a subfolder, you must include folder name. If the aspect is in the same location as the driver, you do not need a folder name.</p>

<h4>Asynchronously</h4>

<p>Aspects can be resolved in parallel mode using keyword "start".</p>

<pre><code class="language-eve">
# asynchronous call demo
driver async_demo:
process
  ** enqueue aspects to be resolved
  start [folder/]one(arguments);
  start [folder/]two(arguments);
  start [folder/]three(arguments);

  ** wait for all aspects to finish
  yield;
return;
</code></pre>

<h4>Parallel processes</h4>

<p>One script can start an aspect with different parameters.</p>

<pre><code class="language-eve">
** resolve several aspects
driver async_loop:
process
  ** enqueue same aspect 4 times
  cycle
    new i: Integer;
  for i in (1..4) loop
    start demo(i);
  repeat;
  wait;
return;
</code></pre>

<h3>Module import:</h3>

<p>The driver or aspect can import modules. After import, all public elements of modules can be used on demand. The parent process is controling the execution logic. Modules are not directly executable and can not have a process, but its public members can be executed and classes can be instantiated.</p>

<p>Modules are "singleton" once a module is loaded in memory, it will not load a second time. Eve is a multi-session system. An aspect can be run asynchronously in parallel but module states are bound the the parent process.</p>

<h3>Exclusive execution:</h3>

<p>When a module is executed, it can be started with parameter: -e or --exclusive. This is a signal that the module can not be started a second time in a separated session by the same VM. In this mode a module can connect to a database in admin mode and can lock a file so that no other process will access the file until is unlocked.</p>

<h2>Program Termination:</h2>

<p>Program can be early terminated be done using: <em>"over"</em> or <em>"panic"</em>. This is a way to release all locked resources and terminate the application. Program can end with an error code using "panic N" statement, otherwise it will automatically return 1 with panic and 0 with "over". Actually "panic 0" is equivalent to "over".</p>

<p>When drive is terminated, it depends what is heppening next. When was started from a console in debug mode the module remains in memory, parsed and ready for debugging. The memory can be investigated using commands. When driver is executed in regular mode, the memory is erased and the EVE machine stop running.</p>

<h4>Example:</h4>

<p>Next code sequence is terminated after 100 iterations:</p>

<pre><code class="language-eve">
# terminate a program with: over
driver test_over:
process
  cycle:
    new i = 0 : Integer;
  loop
    write "."; wait  10;
    over if i > 10;
    let   i += 1;
  repeat;
return;
</code></pre>

<h2><a id="configuration"></a>Configuration</h2>

<p>EVE virtual machine can load system environment variables from a configuration file. These are stored as "$name:value" pairs. Some system constants can be derived from environment variables using concatenation operators "+", "/" or "\".</p>

<p>A configuration file have extension .cfg. One application can run with different configuration file. Application documentation must contain demoduleion of all variables required by the application.</p>

<p>A good practice is to provide a configuration &nbsp;<em>template</em>&nbsp;. The template file may contain comments using Eve syntax that you will learn later. Eve application will automatically parse configuration file to read values for:&nbsp;<em>system variables</em>.</p>
<!-- work in progress-->

<hr>
<p><b>Read next:</b>
<a href="types.html">Data Types</a></p>

<!-- Footer -->
<footer class="footer">
  <div class="footer-copyright text-center"></div>
</footer>
</div>
</body>
</html>