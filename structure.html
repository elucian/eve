<html><head>
  <meta charset="utf-8">
  <meta name="description" content="Sage-Code EVE projectâ€ž structure.">
  <meta name="author" content="Elucian Moise">
  <meta name="keywords" content="sage, code, EVE, project, language">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Website title -->
  <title>EVE Structure</title>

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
  <!-- Icon -->
  <link rel="icon" type="image/png"  href="../images/favicon.ico">
  <!-- EVE code highlighter -->
  <script src="eve.js"></script>
  <!-- Sage-Code custom CSS -->
  <link rel="stylesheet" href="../sage.css">
  </head>
<body onload="eve_render();">

<div class="container">

<!-- header -->
<div class="row">
    <div class="col">
        <a href="https://sagecode.net"><img src="../images/sage-logo.svg" alt="Sage-Code Laboratory" height="80"/></a>
    </div>
    <div class="col  bottom-right">
        <a href="index.html#lang-index">index</a><--
    </div>
</div><hr>

<h1>EVE Structure</h1>

<div class="alert alert-secondary shadow-sm">
EVE is designed to quickly build a data processing app that can run several jobs in order on a precise schedule. You can create one script app but sometimes you need to divide a project into many small scripts that run together.</div>

<h4>Bookmarks:</h4>

<p>Next topics describe overal structure of EVE applications.</p>

<hr>

<ul>
<li><a href="#configuration">Configuration</a></li>
<li><a href="#scripts">Scripts</a></li>
<li><a href="#regions">Regions</a></li>
<li><a href="#globals">Globals</a></li>
<li><a href="#modules">Modules</a></li>
<li><a href="#drivers">Drivers</a></li>
<li><a href="#aspects">Aspects</a></li>
<li><a href="#execution">Execution</a></li>
</ul>

<h2><a id="configuration"></a>Configuration</h2>

<p>One application can load system environment variables from a configuration file. These are stored as "$name:value" pairs. Some system constants can be derived from environment variables using concatenation operators "&amp;","+", "/" or "\".</p>

<p>A configuration file have extension .cfg. It can be used by the compiler or by the application. One application can run with different configuration files. Application documentation must contain description of configuration constants.</p>

<p>Sometimes a&nbsp;<em>file template</em>&nbsp;is provided for copy and modify. Template file may contain comments using Bee syntax that you will learn later. Bee application will automatically parse configuration file to read values for:&nbsp;<em>system constants</em>.</p>

<h2><a id="scripts">Scripts</h2>

<p>Eve scripts are are files with extension *.eve. Scripts can be independent or can use each other in a larger project. A script can have a configuration file, data files and produce a log and data files. One script can be run multiple times but every time is compiled again in memory.<p>

<p>scripts ...</p>
<ul>
<li>have extension *.eve,</li>
<li>can can call each other,</li>
<li>can be run in parallel,</li>
<li>can have a configuration,</li>
<li>can have produce log file,</li>
</ul>

<h4>Kind of Scripts</h4>

<p>Eve define several kind of scripts that together makes a "suite", called project. Some scripts are reusable for many projects but some are specific to a single project. Here are all the possible scripts:</p>

<ul>
<li>Driver script, created with keyword: "driver",</li>    
<li>Aspect script, created with keyword: "aspect",</li>
<li>Module script, created with keyword: "module",</li>
</ul>

<p><b>Notes:&nbsp;</b>One project can contain one or many "driver scripts". Each driver is independend and start a new main process. EVE virtual machine can execute multiple scripts in the same time. A driver script can "import modules". A module is a reusable script that define common elements. </p>

<h4>Restrictions</h4>

<ul>
<li>A module can not import a driver or an aspect script;</li>
<li>A module can be imported but can not be executed;</li>
<li>A driver can <em>call</em> multiple aspects but can not call a driver;</li>
<li>An aspect can <em>call</em> other aspects but can not call itself or a driver.</li>
</ul>

<h2><a id="regions"/>Regions</h2>

<p>A script file is divided into regions using keywords: {import, alias, process, class, function}. Regions are using indentation. A region ends when next region starts.</p>

<h4>Syntax Pattern:</h4>

<p>An EVE script start with one of 3 keywords: {"driver", "aspect", "module"}. Script name is the same as the file name without the extension. A script can have parameters, devined after script name in a list.</p>

<pre><code class="language-eve">
+--------------------------------------------
 Header comments: explain the module purpose  
 These comments can be used on top of module      
---------------------------------------------+

** declare the name and type of a module
[driver | aspect | module] name(parameters):

** set system variables
set $sys_con = value;
...

** public, shared states
set .name = value; 
...

** import region
import
    from $path/library_name use (*);

** qualifier suppression region
alias
    AliasName1 = library_name.MemberName;
    AliasName2 = ClassName[parameters];
    ...
** define user types
type
    user_tupe = {} <: Supertype;
    ...

** private, shared states
set local = value1: user_tupe;
set name  = value2: TypeName;
...

** main process, (executable region)
process main:
    new my_var  = value;  -- private variable
    ...
return;
</code></pre>

<p><b>Note: </b>Any scrupt has a static, global scope. You can define here global states, processes, classes and functions. Notice variables defined in this scope are created using keyword "set".</p>

<h3>System variables</h3>

<p><em>System variables </em>start with prefix "$". Usually are loaded from a configuration file (*.cfg), but sometimes are defiand explicit usually in EVE modules.</p>

<h4>Note:</h4>
<ul>
<li>System variables can be defined in a configuration file,</li>
<li>System variables are usually defined in core modules.</li>
</ul>

<p>Several system variables are provided by EVE environment:</p>
<ul>
<li>$eve_home :eve runtime</li>
<li>$pro_home :project home</li>
<li>$eve_lib  :eve lib folder</li>
<li>$pro_lib  :project lib folder</li>
</ul>

<p><em>System objects</em> are instantiated at startup and are part of core library. These hold runtime information that you can use for debug.</p>

<ul>
<li>$error :contains last error with code & message</li>
<li>$stack :contains debug information about current call stack</li>
<li>$trace :contains reporting information about executed statements
</ul>

<h4>Notes:</h4>
<ul>
<li>User can create new system variables for one application;</li>
<li>Prefix "$" is used to avoid scope qualifier and improve code readability. These variables are environment variables and can be accessed without qualifier;</li>
</ul>

<h3>Public states</h3>

<p>Public states are static variable defined in&nbsp;<em>global scope</em>&nbsp;, with "." prefix. You can access these variables using module qualifier.</p>

<h4>Example</h4>

<pre><code class="language-eve">
** gobal scope
    set  .PI  := 3.14; -- public constant
    set .var := 0;    -- piblic variable
</code></pre>

<h4>Notes:</h4>
<ul>
<li>Shared states are using operator ":=" for initialization,</li>
<li>Constant states are by convention using uppercase letters,</li>
<li>A driver can't define states. That is a driver is stateles.</li>
</ul>


<h3>Import region</h3>

<p>Is used to include members from several other modules into current module:</p>

<h4>Syntax:</h4>
<pre><code class="language-eve">
** define global states
    set $user_path := $root_path/relative_path;

import
    from $user_path use (member_name,...);  -- specific members
    from $user_path use (*);                -- all public members
    ...
</code></pre>

<h4>Notes:</h4>
<ul>
<li>$user_path is any path defined by the user;</li>
<li>spaces in file-names are not supported you must use: "_" instead;</li>
<li>member alias can created from public members of other module;</li>
</ul>

<h3>User types</h3>

<p>In EVE you can define data types, that are very symilar to classes, except the types do not have other methods but the methods of the supertype.</p>

<p>User types are inherited from the supertype or class. When you create this type you can use { }, [ ] or ( ) to define special parameters that are acceptable by the type constructor.<p>

<p>User types are defined in a region that start with keyword "type". You can define types on several lunes of code separated by semicolumn. You can define multiple type regions.</p>

<h3>Private states</h3>

<p>Any script can hold private variables or constants. Private states are defined using keyword "set". These members are not visible outside of current module. Some of these may be using custom types.</p>

<div class="alert alert-warning"><b>Warning: </b>Is considered bad practice to modify global variables inside processes. All processes should depend only on parameters. However EVE do not prevent you from doing so.</div>

<h4>Example</h4>

<pre><code class="language-eve">
type Person = {name:String, age:Integer} <: Object;

** create states using type inference
    set  E    := 2.52; -- Euler's number (constant)
    set  r    := 0.01; -- Real, private state

** create a global object of type Person.
    set  me   := Person("Elucian", "56"); 
</code></pre>

<p><b>Restriction: </b>It is forbitten to use keyword "new" in global scope. All states should be created using keyword "set". This will create static constants or variables on the heap.</p>

<h2><a id="drivers">Drivers</h2>

<p>A&nbsp;<em>driver</em>&nbsp;represents the application main script. It has the role to lead the application main thread. When&nbsp;<em>driver</em>&nbsp;execution is over the application give control back to the operating system.</p>

<h4>Notes:</h4>
<ul>
<li>Any application can have a single driver,</li>
<li>A driver is the application entry point,</li>
<li>A driver can read configuration files at startup,</li>
<li>A driver can receive parameters;</li>
<li>A driver must have one process called "main"</li>
<li>A driver is independent, can not be imported;</li>
<li>A driver do not have public/shared states;</li>
</ul>

<h2><a id="modules"></a>Modules</h2>
<p>Modules are source files having extension: *.eve. Module names are using lowercase letters, can contain underscore or digits but no special characters and no Unicode strings. Longer names that use several words can be separate with underscore. The module name can be 30 characters long.</p>

<h4>Members</h4>
<ul>
<li>public member identifier start with "." prefix;</li>
<li>one module can use public members from other modules;</li>
<li>one module can have public members used by other modules;</li>
<li>member identifier names can be 30 characters long;</li>
</ul>

<h4>Library</h4>
<p>A&nbsp;<em>library</em>&nbsp;is a shared folder containing reusable modules.</p>
<ul>
<li>library contain generic functionality and can be shared between multiple projects;</li>
<li>using import, several modules can be loaded from a folder at once;</li>
<li>circular import is possible: run-time environment has a protection against infinite recursion;</li>
<li>after import you can call public members of a library using&nbsp;<em>dot notation</em>;</li>
</ul>

<h2><a id="aspects">Aspects</h2>

<p>An <em>"aspect"</em> is a script specific to a particular project. It resolve one aspect of a problem. Aspect files are executable scripts. You can call one aspect from another aspect or from the application driver.</p>

<p>An aspect have parameters and main process. You can resolve an aspect by using keyword: "apply" or "defer". An aspect can raise errors.</p>

<h4>Syntax Pattern:</h4>

<pre><code class="language-eve">
aspect name(parameter_list):
    ** declare variables
    ...
process main:
    ** executable region
    ...
return;
</code></pre>

<p><b>Parameters</b>&nbsp; are defined in round brackets () separated by comma. Each parameter must have type and name. Using parameters require several conventions:</p>

<h4>Syntax:</h4>

<p>Mandatory parameters do not have initial values but only type. Optional parameters have initial value that is assign using operator "=" or ":=" and type inference.</p>

<ul>
<li>parameter : Type</li>
<li>parameter  = value :Type</li>
<li>parameter := expression</li>
</ul>

<h4>Notes:</h4>

<ol>
<li>One aspect can receive one or more parameters,</li>
<li>Parameters having initial values are optional,</li>
<li>Values used for parameters in aspect called "arguments",</li>
<li>You can assign arguments by position using a list of values,</li>
<li>You can assign arguments ny name using <code>name:value</code> pairs;</li>
</ol>

<p><b>Variable list of arguments</b></p>
<p>One aspect can receive multiple arguments of the same type separated by comma into a list.</p>
<ul>
<li>First arguments can be captured using named parameters,</li>
<li>The rest of arguments are captured into parameter of type List or Map named: "*args",</li>
<li>An aspect can have one single parameter for varargs,</li>
<li>The list parameter name is declared using sigil: "*",</li>
<li>You can use any name instead of "*args" but this is the usual name.</li>
</ul>

<h4>Example:</h4>
<pre><code class="language-eve"># print all arguments
aspect test(*args <: List[String]):

** list all arguments
process main:
   cycle:
      new arg : string
   for arg in args loop
      print arg;
   repeat;
return;
</code></pre>

<h4>Process context</h4>
<p>Every process has a local private context. In this context a process can define variables, functions and objects but not other processes nor classes. These members can't be shared.</p>

<h4>Output Parameters</h4>
<p>To avoid shared variables you can use input/output parameters. We mark output parameters using symbol "." like parameter is public. Output parameters require a variable as argument, otherwise you will not be able to capture the output value.</p>

<pre><code class="language-eve">
#demo output parameters
driver output_params:

** sub-process
process add(p1 = 0, p2 = 1: Integer, @op: Integer):
   let @op := p1 + p2;
return;

process main:
    new result: Integer;

    ** inpur/output argument require a variable
    apply add(1,2, @op:result);
    print result;     -- expected value 3

    ** negative test, will fail
    apply add(1,2,4); -- error, "out" parameter require a variable
return;
</code></pre>
 
<h4>Notes:</h4>
<ul>
<li>Output parameters are usually the last parameters;</li>
<li>Output parameters are having "@" prefix;</li>
<li>Process calls are statements, not expressions;</li>
<li>You can not create nested processes;</li>
<li>You can not create references to processes;</li>
</ul>


<h2><a id="execution">Script Execution</h2>
<p>EVE scripts are executed using a virtual machine. You can start the virtual machine as a service or as console application. In console you can&nbsp;<em>start</em>&nbsp;only a one script at a time. In service mode you can&nbsp;<em>start</em>&nbsp;multiple sessions with different startup parameters. Each session is independent and can&nbsp;<em>start</em>&nbsp;one single script.</p>

<p><b>Configuration: &nbsp;</b>EVE services using a general configuration file: eve.cfg. This file contains default settings. When the service starts this file is parsed.</p>

<p><b>Memory allocation:&nbsp;</b>EVE service is in charge of allocating memory for one session before the application starts. There is no shared memory between sessions. After application is terminated the memory is released.</p>

<p>To start a driver there are 2 methods:</p>
<ol>
<li>Using the eve system command with parameters,</li>
<li>Using console REPL commands with "start" command.</li>
</ol>

<h4>Running a Driver</h4>

<pre class="language-out">eve:&gt; run ~/path/driver_name -c file.cfg -m 2048GB</pre>

<h3>Driver Execution:</h3>
<p>When a driver is executed, all it's components are compiled in memory, then the <em>process</em> is executed. If a script do not have a "process" called main, it can not be executed. The is the program entry point. When the "driver" is finalized the program terminates and is removed from memory.</p>

<h3>Aspect Execution:</h3>
<p>One aspect is executed from driver or from another aspect. You can not start an aspect from itself. Recursive aspects are not supported. The compiler will detect a recursive aspect and will fail.</p>

<h4>Synchronously</h4>

<p>Aspects can be run in serial mode one after another. Let's consider we have 3 aspects: {one.eve, two.eve, three.eve}. We can execute each aspect using keyword: "apply". This will start main process and wait for it to finish before start the next process:</p>

<pre><code class="language-eve">
** resolve several aspects
process sync_demo:
    ** solve each aspect immediately
    apply one(arguments);
    apply two(arguments);
    apply three(arguments);
    ...
return;
</code></pre>

<h4>Asynchronously</h4>

<p>Aspects can be resolved in parallel mode in different processes.</p>

<pre><code class="language-eve">
** resolve several aspects
process async_demo:
    ** enqueue aspects to be resolved
    begin one(arguments);
    begin two(arguments);
    begin three(arguments);

    ** wait for enqueued aspects to finish
    wait;
return;
</code></pre>

<h4>Parallel Sessions</h4>

<p>One aspect can solve same problem with different parameters.</p>

<pre><code class="language-eve">
** resolve several aspects
driver begin_demo:

process main:
    ** enqueue same aspect 4 times
    cycle
        new i: Integer;
    for i in (1..4) loop
        begin demo(i);
    repeat;
    wait;
return;
</code></pre>

<h3>Module Execution:</h3>

<p>The drivers and aspects can load modules in memory. After loading, all public elements of modules can be used on demand. The driver control the logic of execution.</p>

<p>Modules are "singleton" once a module is loaded in memory, it will not load a second time. Its states are static. EVE is a multi-session system. An aspect can be run asynchronously in parallel but modules are bound the the main process.</p>

<h3>Exclusive Mode:</h3>

<p>When a script is executed, it can be started with parameter: -e or --exclusive. This is a signal that the script can not be started a second time in a separated session by the same VM. In this mode a script can connect to a database in admin mode and can lock a file so that no other process will access the file in parallel.</p>

<h2>Session Termination:</h2>

<p>Script termination can be done using: <em>"exit"</em> or <em>"abort"</em>. This is a way to release all locked resources and terminate the application session. Program can end with an error code using "abort N" statement, otherwise it will automatically return 0 code for the operating system.</p>

<p>When script is terminated, it depends if was started from a console in debug mode or in regular mode. In debug mode the script remains in memory, parsed and ready for debugging. The memory can be investigated using commands.</p>

<h4>Example:</h4>

<p>Next code sequence is terminated after 100 iterations:</p>

<pre><code class="language-eve">
** fast forward demo
driver over_demo:

process main:
    cycle:
        new i = 0 : Integer;
    loop
        write ".";
        wait  100;
        over  if i == 10;
        let   i += 1;
    repeat;
return;
</code></pre>

<!-- work in progress-->

<hr>
<p><b>Read next:</b>
<a href="types.html">Data Types</a></p>

<!-- Footer -->
<footer class="footer">
  <div class="footer-copyright text-center"></div>
</footer>
</div>
</body>
</html>