<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta name="description" content="Sage-Code Eve programming language specification, by Sage-Code Laboratory.">
  <meta name="author" content="Elucian Moise">
  <meta name="keywords" content="SageCode,Sage-Code, EVE, Eve, eve, EveLang, programming language, functions">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Cache-Control" content="no-cache" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />

  <!-- Website title -->
  <title>Eve Functions</title>

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
  <!-- Icon -->
  <link rel="icon" type="image/png"  href="../images/favicon.ico">
  <!-- Eve code highlighter -->
  <script src="eve.js"></script>
  <!-- Sage-Code custom CSS -->
  <link rel="stylesheet" href="../sage.css">
  </head>
<body onload="eve_render();">

<div class="container">

<!-- header -->
<div class="row">
    <div class="col">
        <a href="https://sagecode.net"><img src="../images/sage-logo.svg" alt="Sage-Code Laboratory" height="80"/></a>
    </div>
    <div class="col  bottom-right">
        <a href="index.html#lang-index" rel="nofollow">index</a>&lt;--
    </div>
</div><hr>

<h1><a id="functions">Eve Functions</h1>

<div class="alert alert-secondary shadow-sm">
A function is a relation between input and output values. A function makes a computation to establish the output. Eve functions are objects of type Function. Eve enable functional programming paradigm (FP).</div>

<ul>
<li><a href="#declaration">Function declaration</a></li>
<li><a href="#closures">Closure functions</a></li>
<li><a href="#callbacks">Callback arguments</a></li>
<li><a href="#routines">Routines</a></li>
<li><a href="#coroutines">Coroutines</a></li>
<li><a href="#lambdas">Lambda expressions</a></li>
</ul>

<h2><a href="declaration"></a>Function declaration</h2>

<p>Functions are declared with keyword: "function". A function can be public or private. You can define public functions in modules and private functions in other scripts.</p>

<h4>Pattern:</h4>

<pre><code class="language-eve">#function declaration
function name(parameters) =&gt; (@result:TypeName):
  ** executable block
  ...
return;
</code></pre>

<h4>Notes:</h4>

<ul>
<li>Function result is mandatory and explicit, </li>
<li>Result type must is declared usin prefix @,</li>
<li>A function can have input/output parameters,</li>
<li>A function can receive parameters of type function,</li>
<li>A function can return a result but the result is optional,</li>
<li>A function can create as a result another function called closure,</li>
<li>A function has a name and name. There are no anonymous,</li>
<li>A function can raise errors but it can't handle errors,</li>
<li>A function can be suspended and resumed on demand,</li>
</ul>

<p><b>Execute function</b>&nbsp;Function is executed in expressions using the name of the function followed by semicolumn, and list of arguments in round brackets (). Brackets are mandatory even if there are no arguments.</p>

<p><b>Function arguments</b>&nbsp;The arguments can be pass by position or by name. The names of arguments is useful when when a function has optional parameters.</p>

<h4>Pattern:</h4>

<pre><code class="language-eve">
#demo function execiton
driver function_ex:

** declare functions
function name1(param :Type,...) => (@result:Type):
   let result := expression;
return;

function name2(param := value,...) => (@result:Type):
   let result := expression;
return;

process
  ** execute using argument list
  new result1 := name1(arguments);

  ** execute using parameter names with pair operator (:)
  new result2 := name2(param:arg,....);
return;
</code></pre>

<p><b>Note:</b>&nbsp;Argument value can be an expression or a variable that translate to a value of expected type. For clarity of application we encourage creation of local variables for arguments.</p>

<ul>
<li>value ::= constant | variable</li>
<li>value ::= expression | other function call</li>
</ul>

<h3>Formal parameters</h3>
<ul>
<li>Parameters are declared in parenthesis () after the function name,</li>
<li>Each parameter has name and type and can have one default value,</li>
<li>When a function is called each parameter receive an argument.</li>
</ul>

<h3>Function arguments</h3>

<p>There is a difference between the parameter and the argument. The parameter is a local variable in the function scope while arguments are values assigned to these parameters in a function call. Arguments can be literals, constants, variables or expressions.</p>

<h4>Example:</h4>
<pre><code class="language-eve"># demo function with parameters
driver function_params:

function sum(a, b: Integer) => (@result:Integer):
  let result := (a + b);
return;

process
  print sum(1,2);  -- 3
  print sum(2,4);  -- 6
return;
</code></pre>

<h2><a id="closures"><a>Closures</a>

<p>A closure is a function created by another function. The closure has read/write access to context variables. The context is the scope of parent function, that is called <em>high order function</em>. The context is replicated and bound to every closure instance.</p>

<h4>Why closures?</h4>

<p>Closures are enabled in Eve to offer a convenient way to create generators. These are functions that can return a different result for every call. A closure is a light weight object.</p>

<pre><code class="language-eve">
driver test_closure:

# declare a high order function
function generator(start:Integer) => (@closure:Function):
  new current := start; 

  ** define a closure
  let closure := Function() => Integer: 
      current += 1;
  return;  
process
  new index1 := high_order(0);
  new index2 := high_order(10);
  
  ** interlace the two calls
  print index1(), index1(); -- 1, 2
  print index2(), index2(); -- 11, 12
  print index1(), index1(); -- 3, 4
return;
</code></pre>

<p><b>Note: </b>Closures are stochastic functions, that is oposite to deterministic. The compiler will make no effort to optimize this kind of functions.</p>

<h2><a id="routines"></a>Routines</h2>

<p>A routine is a subprogram that has a name. Can be run in a process on demand. Routines are similar to void functions used in other languages. A routine has no result but it can have side-effects.</p>

<pre><code class="language-eve">
driver routine_demo:

** mandatory arguments
routine first_routine(param1, param2: Type):
  print param1, param2;
return;

** optional arguments
routine second_routine(param1:=default1, 
                       param2:=default2, 
                       param3:=default3):
  print param1, param2, param3;
return;

process
  ** execute routine with arguments
  first_routine value1, value2;

  ** execure routine with no arguments
  secon_routine;

  ** use only 2 arguments from a list of 3 possible
  secon_routine(param1:value1, param3:value3);
return;
</code></pre>

<h2><a id="coroutines"><a>Coroutines</a></h2>

<p>A coroutine is a subprogram that has a name can can be run asybchronously in a parallel thread. Coroutines can yield for another coroutine. Parent process can also yield for all the coroutines to finish.</p>

<h4>Example</h4>

<pre><code class="language-eve">
driver coroutine_demo:

** coroutine producer, make 1000 numbers
routine producer(@pipeline: ()Integer):
  cycle:
    new i: Integer;
  for i in (1..1000) loop
    let pipeline += random(100);
    if (i % 100) == 0 then
      yield consumer;
    done;
  repeat;
return;

** consume 1000 numbers
routine consumer(@pipeline: ()Integer):
    new i:= 0;
    loop
      cycle:
        new element: Integer;
      for element in pipeline loop
        let  pipeline := pipeline -> element;
        print element; 
        let i += 1;
      repeat;
      yield producer;
    repeat if i < 1000;
return;

process
  ** execute routine with arguments
  new pipeline = (): ()Integer;

  ** execute producer/consumer
  run producer(pipeline);
  run consumer(pipeline);
 
  yield all;

  expect pipelie.count() == 0; 
return;
</code></pre>


<h2><a id="lambdas"></a>Lambda expressions</h2>

<p>Lambda expressions are simpler functions that respect arithmetic rules. These can receive several arguments and can produce one result. A lambda expression is created with keywords "set" or "new". Lambda expressions do not have local variables or states and do not have side effects.</p>

<p>Lambda expressions can be declared in "lambda" regions. You can define more than one lambda regions in a script. You can also create new lambda expressions at runtime. Sometimes lambda expressions are anonymous.</p>

<h4>Example</h4>

<p>In next example we define two lambda expressions.</p>

<pre><code class="language-eve">
lambda
  set sum = (p1, p2 :Integer) => (p1 + p2):Integer;
  set sqr = (p1, p2 :Integer) => (p1 * p2):Integer;
</code></pre>

<h3>Lambda signature</h3>

<p>Labda expression signature can be declared as data type using keyword "class". This feature can be used to enforce a specific signature for a <em>call-back</em> argument.<p>

<pre><code class="language-eve">
# define a lambda signature
driver lam_sig

** Sefine callback signature
class BinEx = (p1, p2 :Integer):Integer <: Lambda;

** Use lambda signature as parameter type
function useLambda(test :BinEx):
   print test(); -- execute callback
return;

** Execute a process with lambda argument
process
   ** use anonymous lambda argument
   useLambda((x, y) => (x + y));
return;
</code></pre>

<p><b>Note: </b>Lambda expressions can be created by a function or method but access to external context is read only. A Lambda expression can not modify values of external context.</p>

<h3>Lambda & states</h3>

<p>Lambda expressions can read global and local states, but can not modify any of these states. After expression is defined, the state values can change. The function result is influenced by the new value. So the function was actually not changed but the result is different second time.</li>

<h4>Example:</h4>

<pre><code class="language-eve">
# verify shared state influence
driver shared_states:

** define global settings
  set decimals = 2: Integer;

lambda
  set round = (x:Double) => floor(x * 10^decimal)/10^decimal) :Double;

process
  ** call the lambda expression
  print round(10/3) -- expected 3.33

  ** overvrite the initial settings 
  let decimals := 4;
  print round(10/3) -- expected 3.3333
return;
</code></pre>

<div class="alert alert-wardning"><b>Warning: </b>Observe we have used "set" to create the initial value for a global variable. Then we alter the settings using "let". The new setting overvrite the previous. The new value is used by the function so you get more decimals after round().</div>

<p><b>Disclaim: </b>We know functional programming should not allow this to happen. This is not a secondary effect but is considered a bad practice by functional programming advocates. We aknowledge, Eve is not a pure functional language. This behaviour is present in many other modern languages and is expected. Eve is not different.</p>

<!-- work in progress-->

<hr>
<p><b>Read next:</b>
<a href="collections.html">Collections</a></p>

<!-- Footer -->
<footer class="footer">
  <div class="footer-copyright text-center"></div>
</footer>
</div>
</body>
</html>