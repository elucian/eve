<html><head>
  <meta charset="utf-8">
  <meta name="description" content="Sage-Code Eve data processing. Feature requirement document">
  <meta name="author" content="Elucian Moise">
  <meta name="keywords" content="SageCode, EVE, data processing, collection builder, union, append, enqueue, dequeue, hashmap">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Website title -->
  <title>Eve Processing</title>

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
  <!-- Icon -->
  <link rel="icon" type="image/png"  href="../images/favicon.ico">
  <!-- Eve code highlighter -->
  <script src="eve.js"></script>
  <!-- Sage-Code custom CSS -->
  <link rel="stylesheet" href="../sage.css">
  </head>
<body onload="eve_render();">

<div class="container">

<!-- header -->
<div class="row">
    <div class="col">
        <a href="https://sagecode.net"><img src="../images/sage-logo.svg" 
           alt="Sage-Code Laboratory" height="80"/></a>
    </div>
    <div class="col  bottom-right">
        <a href="index.html#lang-index">index</a><--
    </div>
</div><hr>

<h1>Eve Processing</h1>

<div class="alert alert-secondary shadow-sm">Data processing is an important use case of Eve. A process can define collections, add/modify or remove data in these collections, make computations and decision statements to solve problems. Here are some examples:</div>

<h4>Bookmarks:</h4>
<hr>
<ul>
<li><a href="#main-process">Main process</a></li>
<li><a href="#list-operations">List operations</a></li>
<li><a href="#collection-iteration">Collection iteration</a></li>
<li><a href="#scanning-items">Scanning items</a></li>
<li><a href="#using-hash-map">Using HashMap</a></li>
<li><a href="#text-functions">Text functions</a></li>
</ul>
<hr>

<h2><a id="main-process"/>Main Process</h2>

<p>A process is a series of jobs, executed in serial mode. Any job can pass or fail but the process continue with the next job, unless an exception occours.</p>  

<p>In case of exception, control jump to one of error cases. If none of the cases is handling the error, the recover section is executed. After error is handled the finalize region is executed.</p>

<h4>Pattern:</h4>

<pre><code class="language-eve">
# define process with label
process name(param <: type, ...):
    ** local declarations
    ....
  job (c1,"description") try
    ...
    raise "error" if condition;
    ...
    over if condition;
    ...
    pass if condition;
    ...
    fail if condition;
    ...
  job (c2,"description") try
    ...
  job (c3,"description") try
    ...
recover
  ** exception handlers
  case error1 then
    ** exception handler
    ...
    abort; -- terminate process
  case error2 then   
    ...
    retry;
  else
    raise; -- propagate the error
finalize
    ** close resources
    ...
    ** report the errors
    ...
return;
</code></pre>

<h3>Process Keywords</h3>

<p>The process is created and controlled by many keywords. Mastering these keywords is important to handle use the process as intended to. We have chosen keyword chareful to be easy to memorize.</p>

<table class="table table-sm table-bordered">
<tr><th>process</th><td>create a callable process</td></tr>
<tr><th>job</th><td>create one step in the process</td></tr>
<tr><th>try</th><td>begin job executable block</td></tr>
<tr><th>pass</th><td>skip the rest of task and continue next</td></tr>
<tr><th>fail</th><td>skip then rest of task and continue next</td></tr>
<tr><th>retry</th>
  <td>redo the task that raise a recoverable error</td></tr>
<tr><th>resume</th>
  <td>execute next job, following the one with error</td></tr>
<tr><th>abort</th>
  <td>ignore all next jobs and execute the finalize region </td></tr>
<tr><th>raise</th><td>create a recoverable error, jump to cases</td></tr>
<tr><th>panic</th><td>jump to finalize and stop the application</td></tr>
</table>

<h4>Notes</h4>

<ul>
<li>A process create a loocal scope. All variables define in local scope will be removed when process is ending;</li>
<li>All tasks of a single process are execute sequential from top down;</li>
<li>When the last task is finished the process is ending.</li>
<li>Process main() is mandatory for any driver/aspect. A module do not have a processes. </li>
<li>You can't define classes, functions or processes nested in other processes, but you can create lambda functions.</li>
<li>An aspect can implement multiple processes. All processes are public except processes starting with "_".</li>
</ul>

<h4>Process Interruption</h4>

<p>Interruption keywords (exit, over, panic) can be used to interrupt a process but is not the normal way to terminate a process. These keywords are used to terminate without finalization. Only the <em>abort</em> or <em>raise</em> will trigger the finalization region.</p>

<p><b>Routine call</b>&nbsp;Routines can be used in call statements. A process call can be done using "apply process_name" followed by arguments. For one single argument, or no argument the parentheses are not required.</p>

<pre><code class="language-eve">#these are all valid process calls
apply process_name; -- call process without arguments
apply process_name argument_value;     -- call with single argument
apply process_name value1, value2;     -- call with multiple arguments
apply process_name (value, value, ...); --call with a list of arguments
apply process_name (param:value,...);   -- call with a argument by name
apply process_name (value, value, param:value); -- mix position with names
apply process_name (value, *list_args);         -- mix position with list
apply process_name (param:value, *map_args);    -- mix names with hashmap
</code></pre>

<p><b>Routine termination</b>&nbsp;A process end with keyword return; When process is terminated, program execution will continue with the next statement after the process call. Keyword <em>exit</em> can terminate a process early. If the result do not have initial value and process terminate early the result may be null.</p>

<h4>Example:</h4>
<pre><code class="language-eve"># driver with parameters
driver process_call

process test(Integer a):
  ** print is a system process
  print 'argument list has # members' ? a;
return;

process main(*args ()String): 
  ** number of arguments received:
  new c := args.length();

  ** verify condition and exit
  exit if c == 0;  -- early interruption
  apply test(c);   -- process call
return;
</code></pre>

<h4>Side Effects</h4>
<p>A process can have side-effects:</p>

<ul>
  <li>modify a shared variable;</li>
  <li>open and write into a file;</li>
  <li>print a message or accept input from console;</li>
</ul>

<p><b>using side-effects</b></p>
<p>Next process: "add_numbers" has 2 side effects:</p>
<pre><code class="language-eve">
#test side-effects
driver side_effect:

set test   :Integer;
set p1, p2 :Integer;

** process with side effects
process add_numbers:
  ** side effects
  new test := p1 + p2; --  first side-effect
  print test;          --  second side-effect
return;

** define main process
process main:
  let p1 := 10;      
  let p2 := 20;     
  apply add_numbers; --  call process add_numbers;
  expect (result == 30);
return;
</code></pre>

<h2><a id="list-operations"></a>List operations</h2>
<p>There are many things you can do with a list. You can add/remove elements at both ends. You can deconstruct a list and you can concatenate lists together. Most important features are implemented as built-in functions or special operators:</p>

<p><b>Append to list</b></p>

<p>List is using operator &ldquo;+&rdquo; to grow. This operator represent append. You can append an elemnt to a list but you can also append a list to an element./p>

<pre><code class="language-eve">
#list demo concatenation
driver list_concat:
process main:
  ** initialized list
  new a := ('a','b'); 
  new b := ('1','3'); 

  ** append a list
  new c := a <+ b;
  expect c ==  ('a','b','1','2');

  ** append element
  new d := a + 'z';
  expect d ==  ('a','b','1','2','z');

  ** insert element
  new e := "x' + a;
  expect e ==  ('x','a','b','1','2');
return;
</code></pre>

<p><b>Alter list</b></p>

<p>You can use "let" with operators { += -= }, to append or remove elements from a lit. Notice "+=" will add only at the begining of a list. You can remove an element by value using operator "-=". Only first element having specified value will be remove.</p>

<pre><code class="language-eve">
#list demo concatenation
driver list_alter:
process main:
  ** initialized list
  new lst := ('a','b','c','b'); 

  ** create a new element at the end
  let lst += 'z';
  expect lst ==  ('a','b','c','b','z');

  ** remove all "b" from list
  let lst -= 'b';
  expect lst ==  ('a','c','z');
return;
</code></pre>

<div class="alert alert-info">The list is prepared to support queue and stack. It has all the opperations required. We can implement a class wraper with the sugestive method names.</div>

<p><b>Note:</b>&nbsp;There is no protection about using a List as stack or queue. Is developer responsability to append and remove correctly using one of the operators: {+=, -=, <-, ->}. </p>

<p><b>Queue (FIFO)</b></p>

<p>FIFO = First in First Out</p>

<p>For queue, two operations are possible</p>
<ul>
<li>enqueue, - append to the beginning of the List</li>
<li>dequeue, - extract last element from the List</li>
</ul>

<pre><code class="language-eve">
#remove elements from list
driver list_remove:
  ** initialized queue
  set queue := ()Symbol; 
process main:
  ** enqueue one element
  let queue += "x";
  expect queue ==  ('x');
  ** engueue several elements
  let queue += ('z','y')
  expect queue ==  ('z', 'y', 'x')

  ** deque with new element
  new e: Symbol; let queue -> e; 
  expect queue ==  ('z', 'y');
  expect e == 'x';
return;
</code></pre>

<p><b>Stack</b></p>

<p>LIFO = Last in Last Out</p>

<p>For stack, two operations are possible</p>
<ul>
<li>push  - can append elements at beginning of List</li>
<li>pop   - can extract the first element of the List</li>
</ul>

<pre><code class="language-eve">
#remove elements from list
driver list_remove:
  ** initialized stack
  set stack := ('a','b','c'); 
process main:
  ** append element at the beginning
  let Symbol += 'x'
  expect stack ==  ('x','a','b','c');

  ** extract element from the beginning
  new x <- stack;
  expect stack ==  ('x','a','b','c');
  expect x == 'x';
return;
</code></pre>

<p><b>List methods</b></p>

<p>A List is a class, so it has all required methods and properties to be used in algorithms and expressions. We do not yet forsee all methods bu maybe these would be useful</p>

<pre><code class="language-eve">
List.empty();  -- true/false
List.full();   -- true/false
List.capacity; -- list with capacity
</code></pre>

<h4>Join() method</h4>

<p>The join method receive a list and convert elements into a string separated be specified character.</p>

<pre><code class="language-eve">
#list join() demo
process list_join:
  new str := (1,2,3).join(",");
  expect str == "1,2,3";
return;
</code></pre>

<p><b>Split() method</b>&nbsp;The split method is actually a method of a string, that create a list of strings by splitting a long string into parts.</p>

<pre><code class="language-eve">
** string split demo
process list_split:
  new list: ()Integer; --  empty List
  ** initialize new reference for "lst"
  let lst := "1,2,3".split(",");
  expect lst == (1,2,3);
return;
</code></pre>

<h2><a id="collection-iteration"></a>Collection iteration</h2>

<p>We can use a &nbsp;<em>for loop</em>&nbsp; that is executed for each element belonging to a collection. All collections are iterable.</p>

<h4>Example:</h4>

<pre><code class="language-eve">
#iteration process
driver test_iteration:
  set collection := ('a','b','c');
process main:
  cycle: 
    new element: Symbol;
  for element is collection loop
     write element;
     write ',' if element is not collection.last;
  repeat;
  print;
return;
</code></pre>


<h4>Example:</h4>

<pre><code class="language-eve"># list iteration
driver list_iteration:
  set my_list: {}(Symbol); --  this list is Null
process main:
  let my_list := ['a','b','c','d','e'];
  cycle:
    new e: Symbol;
  for e in my_list loop
    write e;
    if e == 'd' then
      break; --  early termination;
    else
      write(',');
    done;
  repeat;
  print; -- a,b,c,d
return;
</code></pre>

<h2><a id="using-hash-map"></a>Using HashMap</h2>
<p>Maps are sorted in memory by&nbsp;<em>key</em>&nbsp;for faster search. It is more difficult to search by value because is not unique and not sorted. To search by value one must create a loop and verify every element. This is called full scan and is very slow so you should never use this process.</p>

<h3>Map Initialization</h3>

<p>Initialize a collection later than declaration.</p>

<pre><code class="language-eve"># local map initialization
driver map_init:
  my_map:HashMap; -- uninitialized collection
process main:
  ** initialize my_map with values
  let my_map := {(1:'a'),(2:'b'),(3:'c')};

  ** check if a key is present in a map collection
  expect 3 in my_map; -- will pass
return;
</code></pre>

<h3>Create Elements</h3>

<pre><code class="language-eve">** create new elements
process map_append:
  set animals: {}(String, String): ; -- empty collection
process main:
  ** create new element pairs
  let animals += ("Bear":"dog");
  let animals += ("Kiwi":"bird");

  ** verify effect of append
  print  animals;
return;
</code></pre>

<h4>Output:</h4>

<pre class="output">
{('Bear':'dog'),('Kiwi':'bird')}
</pre>

<h3>Modify Elements</h3>
<pre><code class="language-eve">#update a map
driver map_update:
  set animals := {("dogs":0),("birds":0)};
process main:
  ** print the new collection
  print  animals;

  ** modify the collection
  new animals['dogs']   := 1; -- new element
  new animals['birds']  := 2; -- new element
  let animals['birds']  += 3; -- alter element

  ** print the new collection
  print  animals;
return;
</code></pre>

<h4>Output:</h4>
<pre class="output">
{"dogs":0,"birds":0};
{"dogs":1,"birds":5};
</pre>

<h3><a id="scanning-items" ></a>Iteration of Map items</h3>
<p>Collections have common methods that enable traversal using&nbsp;<em>for</em>&nbsp;loop.</p>
<p>{List, Map, Set}</p>
<p><b>built-in:</b></p>
<ul>
<li>count - retrieve the number of elements</li>
<li>capacity - retrieve the maximum capacity</li>
<li>next - position next element</li>
<li>first - position to first element</li>
<li>last - position to last element</li>
<li>this - reference to current element</li>
</ul>
<p><b>set iteration</b>&nbsp;Map and Set are similar. We can visit all elements using&nbsp;<em>for</em>&nbsp;loop:</p>

<h4>Example:</h4>
<pre><code class="language-eve"># map iteration
driver map_iteration:
  set my_map := {("a":1),("b":2),("c":3)};

process main:
  cycle: 
    new key: Symbol;
    new value: Integer;
  for (key: value) in my_map loop
    ** print pairs (key:value)
    print "(#s:#n)" ? (key, value);
  repeat;
return;
</code></pre>

<p>Will print:</p>
<pre class="output">
("a",1)
("b",2)
("c",3)
</pre>

<h2><a id="string-concatenation" ></a>String: concatenation</h2>
<p>Strings can be concatenated using:</p>
<ul>
<li>non trim concatenation operator: "+"</li>
<li>all trim concatenation operator: "-"</li>
<li>path concatenation operator: "/"</li>
</ul>
<h4>Example:</h4>
<pre><code class="language-eve">** example of string concatenation
driver string_concat:
  set str = "";  -- empty String
process main:
  ** set string value using different operators
  let str := "this " + " string"; expect str == "this  string";
  let str := "this " - " string"; expect str == "this string";
  let str := "this/" / " string"; expect str == "this/string";
return;
</code></pre>

<p><b>path concatenation</b></p>
<p>Two strings can be concatenated using concatenation operator "/". Notice "/" will remove exra "/" from a path to avoid doubling it.</p>

<pre><code class="language-eve">
# path concatenation
process path_concat
  new s = ""; -- empty string
  let s := "te/" / "/st"; --  "te/st" 
return;
</code></pre>


<h2><a id="text-functions" ></a>Text functions</h2>
<ul>
<li>Text: replace(Text: str, String: target, String: arrow );</li>
<li>Integer find (Text: str, String: pattern);</li>
<li>Integer count (Text: str, String: pattern);</li>
<li>Integer length (Text: str);</li>
</ul>
<p><b>Note:</b>&nbsp;The text also support escape sequences like a normal string. In a text literal we do not have to escape the single quote symbols: "'". However we have to escape the double quotes like: "This is "quoted" text". This is very rare since quoted text should use symbols: "&laquo; &raquo;" like "&laquo;quoted&raquo;"</p>

<!-- work in progress-->

<hr>
<p><b>Read next:</b>
<a href="library.html">Standard Library</a></p>

<!-- Footer -->
<footer class="footer">
  <div class="footer-copyright text-center"></div>
</footer>
</div>
</body>
</html>