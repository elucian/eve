<html><head>
  <meta charset="utf-8">
  <meta name="description" content="Sage-Code Eve data processing. Feature requirement document">
  <meta name="author" content="Elucian Moise">
  <meta name="keywords" content="SageCode, EVE, data processing, collection builder, union, append, enqueue, dequeue, hashmap">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Website title -->
  <title>Eve Processing</title>

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
  <!-- Icon -->
  <link rel="icon" type="image/png"  href="../images/favicon.ico">
  <!-- Eve code highlighter -->
  <script src="eve.js"></script>
  <!-- Sage-Code custom CSS -->
  <link rel="stylesheet" href="../sage.css">
  </head>
<body onload="eve_render();">

<div class="container">

<!-- header -->
<div class="row">
    <div class="col">
        <a href="https://sagecode.net"><img src="../images/sage-logo.svg" 
           alt="Sage-Code Laboratory" height="80"/></a>
    </div>
    <div class="col  bottom-right">
        <a href="index.html#lang-index">index</a><--
    </div>
</div><hr>

<h1>Eve Processing</h1>

<div class="alert alert-secondary shadow-sm">Data processing is an important use case of Eve. A process can modify states, initialize variables, add/modify or remove data in collections, make computations and decision statements to resolve problems. Next we analyse some use cases:</div>

<h4>Page bookmarks:</h4>
<hr>
<ul>
<li><a href="#main-process">Main process</a></li>
<li><a href="#side-effects">Side effects</a></li>
<li><a href="#list-operations">List operations</a></li>
<li><a href="#collection-iteration">Collection iteration</a></li>
<li><a href="#scanning-items">Scanning items</a></li>
<li><a href="#using-hash-map">Using HashMap</a></li>
<li><a href="#text-literals">Text literals</a></li>
</ul>
<hr>

<h2><a id="main-process"/>Main Process</h2>

<p>A process is sequence of jobs, executed in serial mode. Any job can pass or fail but the process continue with the next job, unless an exception is raised or process is intrerupted early by logic conditions.</p>  

<p>In case of exception, the workflow jumps into recover region. If none of the cases is handling the error, the finalization region is executed and the process terminates. Unhandled errors will cause the program to panic and stop working. Errors do not propagate to other processes.</p>

<h4>Pattern:</h4>

<pre><code class="language-eve">
# define process with label
process
    ** local declarations
    ....
  job (c1,"description") try
    ...
    raise "error" if condition;
    ...
    over if condition;
    ...
    pass if condition;
    ...
    fail if condition;
    ...
  job (c2,"description") try
    ...
  job (c3,"description") try
    ...
recover
  ** exception handlers
  case error1 then
    ** exception handler
    ...
    abort; -- terminate process
  case error2 then   
    ...
    retry;
  else
    panic; -- stop the program
finalize
    ** close resources
    ...
    ** report the errors
    ...
return;
</code></pre>

<h3>Process Keywords</h3>

<p>The process is created and controlled by many keywords. Mastering these keywords is important to use the process effective. We have chosen keyword chareful to be easy to memorize.</p>

<table class="table table-sm table-bordered">
<tr><th>job</th><td>create one step in the process</td></tr>
<tr><th>try</th><td>begin job executable block</td></tr>
<tr><th>pass</th><td>skip the rest of task and continue next</td></tr>
<tr><th>fail</th><td>skip then rest of task and continue next</td></tr>
<tr><th>retry</th>
  <td>redo the task that raise a recoverable error</td></tr>
<tr><th>resume</th>
  <td>execute next job, following the one with error</td></tr>
<tr><th>abort</th>
  <td>ignore all next jobs and execute the finalize region </td></tr>
<tr><th>raise</th><td>create a recoverable error, jump to cases</td></tr>
<tr><th>panic</th><td>jump to finalize and stop the application</td></tr>
</table>

<h4>Notes</h4>

<ul>
<li>An driver must implement one process;</li>
<li>An aspect can implement one process;</li>
<li>A process create a loocal scope.</li> 
<li>Process local variables are allocated dynmaicly when process starts;</li>
<li>All tasks of a single process are execute sequential from top down;</li>
<li>When the last task is finished the local variables are removed;</li>
<li>You can create local lambda expressions and objects;</li>
<li>You can't define classes, or functions in processes;</li>
</ul>

<h4>Process interruption</h4>

<p>Interruption keywords (exit, over, panic) can be used to interrupt a process but is not the normal way to terminate a process. These keywords are used to terminate without finalization. Only the <em>abort</em> or <em>raise</em> will trigger the finalization region.</p>

<p><b>Process execution</b>&nbsp; A process can be executed using "apply" or "start". For one single argument, or no argument the parentheses are not required. For a list of arguments you specify a list of arguments;</p>

<pre><code class="language-eve">#these are all valid process calls
apply process_name; -- call process without arguments
apply process_name argument_value;      -- call with single argument
apply process_name (value, value, ...); --call with a list of arguments
apply process_name (param:value,...);   -- call with a argument by name
apply process_name (value, value, param:value); -- mix position with names
apply process_name (value, *list_args);         -- use spreading operator
apply process_name (param:value, *map_args);    -- mix names with hashmap
</code></pre>

<p><b>Routine termination</b>&nbsp;A process end with keyword return; When process is terminated, program execution will continue with the next statement after the call. Keyword <em>over</em> / <em>exit</em> / <em>panic</em> / <em>abort</em> can terminate a process early.</p>

<h4>Example:</h4>

<pre><code class="language-eve">
# aspect with one parameter
aspect print_this(p:String):
process 
  print p;
return;
</code></pre>

<pre><code class="language-eve"># driver with parameters
driver process_call(*args ()String):
process 
  ** number of arguments received:
  cycle:
    new arg: String;
  for arg in args loop;
    apply print_this String(arg);
  repeat;
return;
</code></pre>

<h2><a id="side-effect"></a>Side Effects</h2>

<p>A process can use states. When a state is changed by a function or method this is called side-effect. This may be good or dangerous. You must be aware of functions, methods or processes with side effects.</p>

<p>these are side effects...</p>

<ul>
  <li>modify a shared variable or state;</li>
  <li>open and write into an external file;</li>
  <li>print a message or accept input from console;</li>
  <li>upload something on internet or network;</li>
</ul>

<h4>Examples</h4>

<p>Next function: "add_numbers" has 2 side effects:</p>
<pre><code class="language-eve">
driver side_effect:
  set test   :Integer;
  set p1, p2 :Integer;

** function with side effects
function add_numbers():
  new test := p1 + p2; -- first side-effect
  print test;          -- second side-effect
return;

** define main process
process
  let p1 := 10;      
  let p2 := 20;     
  apply add_numbers; --  call process add_numbers;
  expect (result == 30);
return;
</code></pre>

<h2><a id="list-operations"></a>List operations</h2>

<p>There are many things you can do with a list. You can add/remove elements at both ends. You can deconstruct a list and you can concatenate lists together. Most important features are implemented as built-in functions or special operators:</p>

<h4>Append to list</h4>

<p>List is using operator +&gt; or &lt;+ to grow. This operator represent insert or append. You can insert an elemnt or many elements into a list at the beginning or you can add element or list of elements at the end but you can not insert elements in the middle of the list./p>

<pre><code class="language-eve">
#list demo concatenation
driver list_concat:
process
  ** initialized list
  new a := ('a','b'); 
  new b := ('1','3'); 

  ** concatenate two lists
  new c := a &lt;+ b;
  expect c ==  ('a','b','1','3');

  ** concatenate two lists
  new d := b +&gt; b;
  expect c ==  ('1','3','a','b');
return;
</code></pre>

<h4>Alter a list</h4>

<p>You can use "let" with operators { += -= }, to append or remove elements from beginning of lit. You can remove any element from a list using "-=". All elements having specified value will be remove. To remove one single element you must use operator &lt;-, or -&gt;</p>

<pre><code class="language-eve">
#altering a list
driver list_alter:
  set lst :()Symbol;
process
  ** initialized list
  let lst := ('a','b','c','b'); 

  ** create a new element at the beginning
  let lst += 'z';
  expect lst ==  ('a','b','c','b','z');

  ** remove all "b" from list
  let lst -= 'b';
  expect lst ==  ('a','c','z');

  ** append element to list 
  let a := a <+ 'x';
  expect a ==  ('a','c','z','x');

  ** enque element in list
  let a := 'v' +> a;
  expect a ==  ('v','a','b','z','x');
return;
</code></pre>

<div class="alert alert-info">The list is prepared to support queue and stack. It has all the opperations required. We can implement a class wraper with the sugestive method names.</div>

<p><b>Note:</b>&nbsp;There is no protection about using a List as stack or queue. Is developer responsability to append and remove correctly using one of the operators: {+=, -=} {:=, &lt;-, -&gt;}. </p>

<p><b>Queue (FIFO)</b></p>

<p>FIFO = First in First Out</p>

<p>For queue, two operations are possible</p>
<ul>
<li>enqueue, - append to the beginning of the List</li>
<li>dequeue, - extract last element from the List</li>
</ul>

<pre><code class="language-eve">
#remove elements from list
driver list_remove:
  ** initialized queue
  set queue := ()Symbol; 
process
  ** enqueue one element
  let queue += "x";
  expect queue ==  ('x');
  ** engueue several elements
  let queue += ('z','y')
  expect queue ==  ('z', 'y', 'x')

  ** create new element and dequeue
  new e: Symbol; let queue := queue -&gt; e; 
  expect queue ==  ('z', 'y');
  expect e == 'x';
return;
</code></pre>

<p><b>Stack</b></p>

<p>LIFO = Last in Last Out</p>

<p>For stack, two operations are possible</p>
<ul>
<li>push  - can append elements at beginning of List</li>
<li>pop   - can extract the first element of the List</li>
</ul>

<pre><code class="language-eve">
#remove elements from list
driver list_remove:
  ** initialized stack
  set stack := ('a','b','c'); 
process
  ** append element at the beginning
  let Symbol += 'x';
  expect stack ==  ('x','a','b','c');

  ** extract element from the beginning
  new x &lt;- stack;
  expect stack ==  ('x','a','b','c');
  expect x == 'x';
return;
</code></pre>

<h4>List methods</h4>

<p>A List is a class, so it has all required methods and properties to be used in algorithms and expressions. We do not yet forsee all methods bu maybe these would be useful</p>

<pre><code class="language-eve">
List.empty();  -- true/false
List.full();   -- true/false
List.capacity; -- list with capacity
</code></pre>

<h4>Join() method</h4>

<p>The join method receive a list and convert elements into a string separated be specified character.</p>

<pre><code class="language-eve">
#call List.join() demo
function list_join:
  new str := (1,2,3).join(',');
  expect str == "1,2,3";
return;
</code></pre>

<p><b>Split() method</b>&nbsp;The split method is actually a method of a String, that create a List of strings by splitting a long string into parts. Usually you split by comma, but any symbol can be used. The separator is removed and will not be part of the resulting list.</p>

<pre><code class="language-eve">
** string split demo
process list_split:
  new list: ()Integer; --  empty List
  ** initialize new reference for "lst"
  let lst := "1,2,3".split(',');
  expect lst == (1,2,3);
return;
</code></pre>

<h2><a id="collection-iteration"></a>Collection iteration</h2>

<p>We can use a &nbsp;<em>for loop</em>&nbsp; that is executed for each element belonging to a collection. All collections are iterable. To be iterable a class need to implement an iterable interface.</p>

<h4>Example:</h4>

<pre><code class="language-eve">
#iteration process
driver test_iteration:
  set collection := ('a','b','c');
process
  cycle: 
    new element: Symbol;
  for element is collection loop
     write element;
     write ',' if element is not collection.last;
  repeat;
  print;
return;
</code></pre>


<h4>Example:</h4>

<pre><code class="language-eve"># list iteration
driver list_iteration:
  set my_list: ()Symbol; --  this list is Null
process
  let my_list := ('a','b','c','d','e');
  cycle:
    new e: Symbol;
  for e in my_list loop
    write e;
    if e == 'd' then
      break; --  early termination;
    else
      write(',');
    done;
  repeat;
  print; -- a,b,c,d
return;
</code></pre>

<h2><a id="using-hash-map"></a>Using HashMap</h2>
<p>Maps are sorted in memory by&nbsp;<em>key</em>&nbsp;for faster search. It is more difficult to search by value because is not unique and not sorted. To search by value one must create a loop and verify every element. This is called full scan and is very slow so you should never use this process.</p>

<h3>Map Initialization</h3>

<p>Initialize a collection later than declaration.</p>

<pre><code class="language-eve"># local map initialization
driver map_init:
  set my_map :HashMap; -- uninitialized collection
process
  ** initialize my_map with values
  let my_map := {1:'a',2:'b',3:'c'};

  ** check if a key is present in a map collection
  expect 3 in my_map; -- will pass
return;
</code></pre>

<h3>Create Elements</h3>

<pre><code class="language-eve">** create new elements
process map_append:
  set animals: {}(String, String): ; -- empty collection
process
  ** append several elements
  let animals += {"Rob":"dog", "Kiwi":"bird"};

  ** create single element
  new animals["Toto":"parot"]
  print  animals;
return;
</code></pre>

<h4>Output:</h4>

<pre class="output">
{"Rob":"dog","Kiwi":"bird","Toto":"parot"}
</pre>

<h3>Modify Elements</h3>
<pre><code class="language-eve">#update a map
driver map_update:
  set animals : {}(String, String);
process
  ** print the new collection
  print  animals;

  ** modify the collection
  new animals["dogs"]   := 1; -- new element
  new animals["birds"]  := 2; -- new element
  let animals["birds"]  += 3; -- alter element

  ** print the new collection
  print  animals;
return;
</code></pre>

<h4>Output:</h4>
<pre class="output">
{}
{"dogs":1,"birds":5};
</pre>

<h3><a id="scanning-items" ></a>Iteration of Map items</h3>
<p>Collections have common methods that enable traversal using&nbsp;<em>for</em>&nbsp;loop.</p>
<p>{List, Map, Set}</p>
<p><b>built-in:</b></p>
<ul>
<li>count - retrieve the number of elements</li>
<li>capacity - retrieve the maximum capacity</li>
<li>next - position next element</li>
<li>first - position to first element</li>
<li>last - position to last element</li>
<li>this - reference to current element</li>
</ul>
<p><b>set iteration</b>&nbsp;Map and Set are similar. We can visit all elements using&nbsp;<em>for</em>&nbsp;loop:</p>

<h4>Example:</h4>
<pre><code class="language-eve"># map iteration
driver map_iteration:
  set my_map := {'a':1,'b':2,'c':3};

process
  cycle: 
    new key: Symbol;
    new value: Integer;
  for (key: value) in my_map loop
    ** print pairs (key:value)
    print "(#s:#n)" ? (key, value);
  repeat;
return;
</code></pre>

<h4>Output:</h4>
<pre class="output">
('a':1)
('b':2)
('c':3)
</pre>

<h2><a id="string-concatenation" ></a>String: concatenation</h2>
<p>Strings can be concatenated using:</p>
<ul>
<li>regular concatenation: "+"</li>
<li>space trim & concatenation: "-"</li>
<li>path concatenation: "/"</li>
</ul>
<h4>Example:</h4>
<pre><code class="language-eve">** example of string concatenation
driver string_concat:
  set str: String;  -- empty String
process
  ** set string value using different operators
  let str := "this " + " string"; expect str == "this  string";
  let str := "this " - " string"; expect str == "this string";
  let str := "this/" / " string"; expect str == "this/string";
return;
</code></pre>

<p><b>path concatenation</b></p>
<p>Two strings can be concatenated using concatenation operator "/". Notice "/" will remove exra "/" from a path to avoid doubling it.</p>

<pre><code class="language-eve">
# path concatenation
process
  new s := ""; -- empty string
  let s := "te/" / "/st"; --  "te/st" 
return;
</code></pre>

<h3><a id="text-literals"></a>Text Literals</h3>

<p>Strings can contain multiple lines separated with end of line character. Large text literal can be defined on multiple lines. This kind of literal is enclosed in triple quotes. """...""".</p>

<p>Triple quoted string support inside double quotes and also single quote without escape. On double quoted strings you must use escape backslash \" for double quotes.</p>

<pre><code class="language-eve"># declaration of a text literal
driver text_literal:

process
  ** triple quoted string
  new my_text:=""" 
         "Opportunity is missed by most people
      because it is dressed in overalls
      and looks like work."
  """; 
  print my_text;
return;
</code></pre>

<p><b>Output:</b></p>
<pre class="output">
    "Opportunity is missed by most people
because it is dressed in overalls
and looks like work."
</pre>

<h2><a id="text-functions" ></a>String functions</h2>
<ul>
<li>replace(target, cargo:String);</li>
<li>find   (pattern:String);</li>
<li>count  (pattern:String);</li>
<li>length ();</li>
</ul>

<p><b>Note:</b>&nbsp;In a text literal we do not have to escape the single quote symbols '&alfa;'. However we have to escape the double quotes like: "This is "quoted" text". This is very rare since quoted text should use symbols: "&laquo; &raquo;" like this"this &laquo;quoted&raquo; string" by convention.</p>

<!-- work in progress-->

<hr>
<p><b>Read next:</b>
<a href="library.html">Standard Library</a></p>

<!-- Footer -->
<footer class="footer">
  <div class="footer-copyright text-center"></div>
</footer>
</div>
</body>
</html>