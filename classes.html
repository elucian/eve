<html><head>
   <meta charset="utf-8">
   <meta name="description" content="Sage-Code Eve object oriented programming. Classes and Objects. ">
   <meta name="author" content="Elucian Moise">
   <meta name="keywords" content="SageCode, EVE, OOP, EveLang, Objects, Object Oriented, paradigm, classes, , methods, consructor">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">

   <!-- Website title -->
   <title>Eve OOP</title>

   <!-- Bootstrap CSS -->
   <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
   <!-- Icon -->
   <link rel="icon" type="image/png"   href="../images/favicon.ico">
   <!-- Eve code highlighter -->
   <script src="eve.js"></script>
   <!-- Sage-Code custom CSS -->
   <link rel="stylesheet" href="../sage.css">
   </head>
<body onload="eve_render();">

<div class="container">

<!-- header -->
<div class="row">
    <div class="col">
        <a href="https://sagecode.net"><img src="../images/sage-logo.svg" 
           alt="Sage-Code Laboratory" height="80"/></a>
    </div>
    <div class="col bottom-right">
          <a href="index.html#lang-index">index</a><--
    </div>
</div><hr>

<h1>Eve OOP</h1>

<div class="alert alert-secondary shadow-sm">
Eve is an object oriented language. We define objects and classes. A class is a <em>user defined data type</em>, that encapsulate data structure and behaviour. An object is an instance of a class. We use classes to create data structures and algorithms.</div>

<p><b>Objects </b>are&nbsp;<em>state machines</em>&nbsp;that are instantiated on demand and released from memory when they are no longer needed. You can create global objects using "set", or local objects using "new" keyword.</p>

<p><b>Classes </b>are objects themselves. Also, classes can be used to generate object instances. All object instances generated from a class, will inherite class structure and behaviour. The most important characteristics of objects are:</p>

<ul>
<li>Encapsulation: each object has its own states;</li>
<li>Inheritance: an object inherit its base class;</li>
<li>Polymorphism: an object can play its base class role;</li>
</ul>

<div class="alert alert-info"><b>Note: </b>Objects can't be abstract but you can define an abstract class that can be extended by other classes or user defined data types. Eve implements all 4 OOP principles. </div>

<h4>Page bookmarks:</h4>

<hr>
<ul>
<li><a href="#class">Class signature</a></li>
<li><a href="#object">Object type</a></li>
<ul>
<li><a href="#object-methods">Object methods</a></li>
<li><a href="#object-attributes">Object attribute</a></li>
</ul>
<li><a href="#class-members">Class members</a></li>
<ul>
<li><a href="#class-properties">Class properties</a></li>
<li><a href="#class-methods">Class methods</a></li>
<li><a href="#constructor">Class constructor</a></li>
</ul>
<li><a href="#class-tree">Class Tree</a></li>
<li><a href="#comparing-objects">Comparing objects</a></li>
<li><a href="#inheritance">Inheritance</a></li>
</ul>


<h2><a id="class"></a>Class signature</h2>

<p>Class is a type declaration. You can declare the class public attributes before implementing the class. This is called "forward declaration". It is useful when you have 2 classes to be defined that depend on each other.</p>

<pre><code class="language-eve">#define an object instance
** declare a class with two attributes
class .MyClass = {a, b: Integer} <: Object;

** create several class signatures in a "class region"
class
  Foo = {attr:Type, ...} <: Object;
  Bar = {attr:Type, ...} <: Object;
  ...
</code></pre>

<h4>Notes:</h4>

<ul>
<li>Usually classes are members of modules;</li>
<li>Drivers and Aspects can define only private classes;</li>
<li>Only modules can define public classes. </li>
<li>Public classes start with (.) prefix.</li>
</ul>

<h2><a id="object">Object type</h2>

<p>Eve is similar to Java. It has a root Object that is actually a composite data type. This can be used as a <em>base class</em>. The Object constructor accept variable number of arguments. You can initialize an object by using the Object constructor.</p>

<pre><code class="language-eve">#define an object instance
process test:
  ** initialize object using Object() constructor
  new object_name := Object(attribute1:value1, 
                            attribute2:value2, 
                            ...);
  ...
return;
</code></pre>

<p><b>Note:&nbsp;</b>Object constructor can receive argument names that do not exist, and bind values to new attributes using (key:value) pairs. This is possible in Eve due to a gradual typing system.</p>

<h3><a id="object-methods"></a>Object methods</h3>

<p>Methods are related to an object or a class. The methods can have parameters and can return results. You must define all methods in the same module as the class declaration. Modules can have public or private classes. Drivers and Scripts can have only private classes.</p>

<h4>Example</h4>

<pre><code class="language-eve">
# define a "Point" class:
driver test_point:

class Point = {x, y :Double} <: Object; 

method (@self:Point) move(a, b: Double):
  let self.x += a;
  let self.y += b;
return;

method (@self:Point)  string() => (string:String):
  let string := "# = (#:#)" ? (self.id, self.a, self.b);
return;

process
  ** initialize the points
  new p := Point(x:1, y:2);

  ** move the point
  p.move(2,1);
  print p.string(); -- (3:3)
return;
</code></pre>

<p><b>Note: </b>To call a method, you do not use any keyword. Just specify the method name with arguments. Methods can be created in packages to extend the Eve language with domain specific actions.</p>

<h3><a id="object-attributes"></a>Object Attributes</h3>

<p>A class can define attributes for future object instances. The class constructor must set initial values for object attributes and can create new private attributes. Attributes can be public or private.</p>

<ul>
<li>We declare attributes using = {...}  or += {...} after class name;</li>
<li>Public attributes must be initialized using "let" in constructor;</li>
<li>Private attributes are created with keyword "new" in constructor;</li>
<li>Private attributes are starting with sigil "_", by convention;</p>
</ul>

<p>To access public attributes you must use dot notation like:</p>

<pre class="output">object_instance.public_attribute;</pre>

<p>To access private attributes you must use "self." qualifier. Private attributes are available in constructor and inside of object methods but are not available with object name as qualifier.</p>

<pre class="output">self._private_attribute;</pre>

<p><b>Note </b>A class does not know anything about its objects. You can not ask the class anything about its instances, except if you create a special logic using class properties.</p>


<h2><a id="class-members"></a>Class members</h2>

<p>A class can have properties and methods. Class properties and metods are static members and must be defined inside the class declaration region. A class can also have static lambda expressions.</p>

<p>An object can have attributes and methods. Attributes are defined by the constructor. Object methods are defined later in the same module, outside of the class body. Object attributes and methods are dynamic.</p>

<h3><a id="class-properties"></a>Class Properties</h3>

<p>As mentioned before, the class has public or private properties. Each property is defined in the class context. We declare class properties after symbol ":" before any class method.</p>

<ul>
<li>Properties are defined using keyword "set" ;</li>
<li>Private properties start with "_" sigil;</li>
<li>Public properties start with dot "." prefix; </li>
<li>A class is a singleton Object of type Class;</li>  
</ul>

<p>To access the public properties you can use class qualifier with dot notation:</p>

<pre class="output">ClassName.property_name;</pre>

<h3><a id="class-methods">Class Methods</h2>

<p>You can define private or public methods inside of a class body. Most of the time you need only private class methods. Public methods start with dot (.) prefix. Private methods do not use a prefix or sigil. Class methods have access to all class members, without using any qualifier:</p>


<pre><code class="language-eve">
driver test_method:

# define a class with constructor
class ClassName <: Object:
  ** class propety
  set _property: Integer; -- private
  set .last: Integer;     -- public

  ** class method
  method .change(param:Type) => (result:Integer):
     let last := param;
     let _property += param;
     let result   := property;
  return;
return;

process
   ** call class method
   new result1 = ClassName.change(10); 
   new result2 = ClassName.change(12); 

   ** check method result
   expect result1 == 10;
   expect result2 == 22;

   ** inspect ".last" property
   expect ClassName.last == 12;
return;
</code></pre>


<h2><a id="class-tree"></a>Class Tree</h2>

<p>Using the <em>"Object"</em> as the <em>"root class"</em>, you can create a hierarchy of classes. Each classes is derived from the Object or from other <em>"superclass"</em> forming a <em>"class tree"</em>. Like a real tree the class hierarchy has a single root.</p>

<div align="center">
   <img src="img/class-tree.svg" alt="Class Tree" width="680" class="img-fluid protect rounded shadow border" >
   <p>Class Tree</p>
</div>

<h4>Example:</h4>

<p>This example defines a "Point" class with two parameters. The parameters have default values so they are optional when you create a point. Read the example and the notes to understand how to use a user defined class constructor.</p>

<pre><code class="language-eve">
# demonstrate a class
driver point_demo:

** define class Point, from root Object
class Point = {x, y :Double} <: Object:

** constructor reveive 2 parameters
create(x = 0, y = 0 :Double) => (@self: Point):
  ** set attribute values
  let self.x := x;
  let self.y := y;
return;

process
  ** initialize the points
  new p1 := Point(x:1, y:2);
  new p2 := Point(x:2, y:2);

  ** use string patterns to print attributes
  print "p1 = (x:#n, y:#n)" ? (p1.x,p1.y);
  print "p2 = (x:#n, y:#n)" ? (p2.x,p2.y);
return;
</code></pre>

<h4>Output:</h4>

<pre class="output">
p1 = {x:1, y:2}
p2 = {x:2, y:2}
</pre>

<h3><a id="constructor"></a>Class Constructor</h3>

<p>You can create more complex objects by using a class constructor. This is a special struture that can be used to describe class members and object instances. A class can have a constructor or can be constructor-less.</p>

<h4>Design:</h4>

<p>A class is a composite data type. It can be derived from another data type or from the root Object. Next design pattern explain how to declare a public class with attributes and constructor:</p>

<pre><code class="language-eve">
# user defined public class   
class .NewType = {attributes} <: Object:
  ** declaration
  ... 
create (parameters) => (@self :NewType):
  ** constructor
  ...    
release
  ** cleanup
  ...
return;
</code></pre>

<p><b>Notes:&nbsp;</b>A class is a singleton. It has public and private members and can describe the attributes of the future object instances. A class has a declaration region where you can define static members, and an initialization region called constructor, for object initialization.</p>

<h4>Pattern:</h4>

<p>A class has one single constructor. Constructors can have one or more parameters, some may be optional. You can use a decision statements to initialize the object attributes in different ways based on parameter values.</p>

<pre><code class="language-eve">
# define a private class
class ClassName = {attributes} <: Object:
   ** define class properties
   set property_name = value;
   ....

   ** define class method
   method test() => (result:Type):
      ...
      result := expression;
   return;
create(parameters) => (@self: ClassName):
  ** conditional initialization
  if condition then
    let self.attribute = value;
    ...
  else
    let self.attribute = other_value;
    ...
  done;
return;
</code></pre>

<h3>Parameters</h3>

<p>A constructor can have parameters with an initial value that are optional. Parameters with no initial values are mandatory. It is possible to have a variable number of arguments, received as a HashMap for a vararg based constructor.</p>

<h4>Example:</h4>

<pre><code class="language-eve">
# define a class derived from root Object
class NewName += {attribute:Type, ....} <: Object;
  ** class body
  ...
create(*parameters: HashMap) => (@self:NewName):
  ...
return;

process
  ** instantiate a local object using constructor
  new object := NewName(param:value,...);
  ...
return;
</code></pre>

<p><b>Note:</b>The <em>object</em> in the previous example, has type: NewName. So you can use the class name as a data type. The data type defined by the class is dynamicly created by the compiler.</p>

<h4>@self object</h4>

<p>Object named "self" is the current object name. This is the result of the class constructor. It uses prefix "@" to show that it is a reference. The "self" parameter is used for declaring object methods. In Java this is an implicit parameter. In Eve you must declare @self explicitly.</p>

<h2><a id="comparing-objects"></a>Comparing objects</h2>

<p>We can use two comparison operators with objects: "is" and "==". First operator "is" will compare the object location. If the objects have the same location they represent the same object. Second operator: "==" compare object type and object attributes or value. There are complementar operators "is not" and "!=". That can be used to create conditionals.</p>

<h4>Example:</h4>

<p>In next examples we use a primitive type: Integer, that is actually a class. So any Integer number is an Object instance. Object instances are references and can be compared.</p>

<pre><code class="language-eve">
#object comparison demo
driver object_compare:
  set m = n = 1: Integer; 
process
  ** equal values and types
  expect   m   == n;
  expect   not (m != n);

  ** not the same location
  expect   not (m is n);
  expect   m is not n;

  ** alter one value
  let n := 2;

  ** equal values and types
  expect   m   != n;
  expect   not (m == n);
return;
</code></pre>


<h2><a id="inheritance"/>Inheritance</h2>

<p>Eve support inheritance and pilymorphism. You can specify a supertype using the symbol "<:" that is equivalent to the keyword: <em>"extend"</em> used in Java. Using this symbol makes a class that has all attributes and methods of the super-class or super-type.</p>

<h4>Pattern:</h4>

<pre><code class="language-eve">
# define a class with inheritance
class BaseType = {attributes} <: Object;

** object method
method (@self:BaseType) demo(param:Type, ...):
   ...
return;

** create a descendent of BaseType
class NewType += {new_attributes} <: BaseType:
  ** class members
  ...
create(parameters) =>(@self: NewType):
  ** call base class constructor
  let self := super(parameters);

  ** create new attributes
  new self.new_attribute := value;

  ...
return;

** overwriten method
method (@self:NewType) demo(parameters) => (result:Type):
   ...
return;
</code></pre>
<hr>

<h2><a id="generics"></a>Generics</h2>

<p>Generics are Eve system lybraries. You can create sub-types using a generic. Next generics are pre-defined: {Array, List, DataSet, HashMap}. We will describe these data types in next chapter.</p>

<h4>Use cases</h4>

<p>Eve enable 4 generic types. If more generic types are required in the future we will modify the language. We will describe these generics as collection types. All these generics are "Iterable" Objects.</p>

<pre><code class="language-eve">
** making an array
class UserArray = []Type <: Array;

** making a list
class UserList = ()Type <: List; 

** making a data set
class UserSet = {}Type <: DataSet; 

** making a dictionary
class UserMap = {}(Type:Type) <: HashMap; 
</code></pre>

<h4>List of DataSet</h4>

<p>Girst you define ElementType, then you define a collection UserList. After this you can define many instantes of type UserList. Then you can engueue or append new members.</p>

<pre><code class="language-eve">
# Using a generic type to create a table
driver test_generic:

** making an element type
class ElementType = {a,b,c: Integer} <: DataSet;

** making a list of elements
class UserList = ()ElementType <: List; 

process
  ** instantiate UserList object 
  new myList: UserList; 

  ** enqueue one member
  let myList += ElementType(1,2,3);

  ** append one member
  let myList := myList + ElementType(7,8,9);

  print myList -- ({1,2,3},{7,8,9})
return;
</code></pre>

<h4>Type Inference</h4>

<p>Using a data literal you can shortcut the design pattern. This is possible due to type inference. Eve create the types for you. After collection is created you can add new elements.</p>

<pre><code class="language-eve">
** define object using type inference
   new myList := ({1,2,3},{7,8,9});

** using introspection to find the type
   print Type(myList);       -- List
   print Type(myList[1]);    -- DataSet
   print Type(myList[1][1]); -- Integer
</code></pre>

<h4>List of Objects</h4>

<p>Using type inference you can create complex data structures. In next example we create a list of objects. Each object can have same structure or different structure. This is possible due to dynamic nature of Objects.</p>

<pre><code class="language-eve">
** define object using type inference
   new myCatalog := ({name: "Elucian", age: 56},{name: "Daniel", age: 45});

** using introspection to find the type
   print Type(myList);          -- List
   print Type(myList[1]);       -- Object
   print Type(myList[1].name);  -- String
   print Type(myList[1].age);   -- Integer
</code></pre>

<p><b>Read next:</b>
<a href="functions.html">Functions</a></p>

<!-- Footer -->
<footer class="footer">
   <div class="footer-copyright text-center"></div>
</footer>
</div>
</body>
</html>