<html><head>
   <meta charset="utf-8">
   <meta name="description" content="Sage-Code Eve object oriented programming. Classes and Objects. ">
   <meta name="author" content="Elucian Moise">
   <meta name="keywords" content="SageCode, EVE, EveLang, Objects, Classes, OOP, method, consructor">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">

   <!-- Website title -->
   <title>Eve Class</title>

   <!-- Bootstrap CSS -->
   <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
   <!-- Icon -->
   <link rel="icon" type="image/png"   href="../images/favicon.ico">
   <!-- Eve code highlighter -->
   <script src="eve.js"></script>
   <!-- Sage-Code custom CSS -->
   <link rel="stylesheet" href="../sage.css">
   </head>
<body onload="eve_render();">

<div class="container">

<!-- header -->
<div class="row">
    <div class="col">
        <a href="https://sagecode.net"><img src="../images/sage-logo.svg" 
           alt="Sage-Code Laboratory" height="80"/></a>
    </div>
    <div class="col   bottom-right">
          <a href="index.html#lang-index">index</a><--
    </div>
</div><hr>

<h1>Eve Classes</h1>

<div class="alert alert-secondary shadow-sm">
Eve is an object oriented language. We define objects and classes. A class is a user-defined data type. It implements behaviour for a data object. Classes are advanced data types that encapsulate data and behaviour.</div>

<h2>Eve Objects</h2>

<p>Objects are&nbsp;<em>state machines</em>&nbsp;that are instantiated on demand and released from memory when they are no longer needed. You can create global objects using "set" or local objects by using "new".</p>

<p>The most important characteristics of objects are:</p>

<ul>
<li>Encapsulation: each object has its own states;</li>
<li>Inheritance: an object inherit its base class;</li>
<li>Polymorphism: an object can play its base class role;</li>
</ul>

<div class="alert alert-info"><b>Note: </b>Objects can't be abstract but you can define an abstract class that can be extended by other classes or user defined data types. Eve implements all 4 OOP principles. </div>

<h4>Bookmarks:</h4>

<hr>
<ul>
<li><a href="#object">Object instances</a></li>
<li><a href="#methods">Object methods</a></li>
<li><a href="#class">Class template</a></li>
<li><a href="#constructor">Class constructor</a></li>
<li><a href="#class-members">Class members</a></li>
<li><a href="#class-tree">Class Tree</a></li>
<li><a href="#comparing-objects">Comparing objects</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#inheritance">Inheritance</a></li>
</ul>

<h2><a id="object"></a>Object Instances</h2>

<p>Objects are variables that need to be initialized using a Class. The most simple object is an instance of type Object. The Object is the fundamental class in EVE, that is why it starts with uppercase.</p>

<h4>Pattern:</h4>

<p>Initialize an object by using an object literal with initialization values:</p>

<pre><code class="language-eve">
# define global object instances
driver test:
  ** empty object
  set object_name1: Object(); 

  ** object with attributes
  set object_name2: {attribute:value, ...} <:Object;
return;
</code></pre>

<p><b>Notes:</b>An object is a reference to a data structure that is created by using the default constructor. This receives a list of attribute-value pairs: {attribute:value, ...}. The default constructor accepts a list of parameters (attribute:value,.)</p>


<h4>Alternative:</h4>

<p>Initialize an object by using an explicit constructor call.</p>

<pre><code class="language-eve">#define an object instance
process test:
  ** initialize object using Object() constructor
  new object_name := Object(attribute1:value1, 
                                        attribute2:value2, ...);
  ...
return;
</code></pre>

<p><b>Note:&nbsp;</b>One object instance can receive attribute names that do not exist and bind values to them using column ":" symbol. Default constructor will create new attributes automatically and set-up an implicit data type using type inference. This is possible due to a gradual typing algorithm.</p>


<h2><a id="methods"></a>Object methods</h2>

<p>Methods are related to an object. The methods can have parameters and can return results. You must define all methods for a type in the same module as the type declaration.</p>

<h4>Example</h4>

<pre><code class="language-eve">
# define a "Point" type:
type Point = {x, y :Double} <: Object; 

method (@self:Point) move(a, b: Double):
   let self.x += a;
   let self.y += b;
return;

method (@self:Point)  string() => (string:String):
   let string := "# = (#:#)" ? (self.id, self.a, self.b);
return;

process main:
   ** initialize the points
   new p := Point(x:1, y:2);

   ** move the point
   apply p.move(2,1);
   print p.string(); -- (3:3)
return;
</code></pre>

<h2><a id="class"></a>Class Template</h2>

<p>You can create more complex objects by using a class template. This is a special object struture that can be used to create objects. A class can have a constructor or can be constructor-less.</p>

<h4>Design:</h4>

<p>A class is a data type. It can be derived from another data type. Usually a class is derived from Object that is the basic data type. Next design pattern explain how to declare a class:</p>

<pre><code class="language-eve">
# user defined class   
class TypeName <: SuperType;
   ** declaration
   ... 
create (parameters) => (@self :TypeName):
   ** constructor
   ...    
release
   ** cleanup
   ...
return;
</code></pre>

<p><b>Notes:&nbsp;</b> A class is a container. It has members that can be public or private. A class has a declaration region where these members are defined, and an initialization region called constructor.</p>

<h3><a id="constructor"></a>Class constructor</h3>

<p>A class has one single constructor. Constructors can have one or more parameters some may be optional. You can use a decision statements to create the object attributes in different ways based on parameters.</p>

<h4>Pattern:</h4>

<p>Class has m

<pre><code class="language-eve">...
class name <: Object:
   ** member declarations
   ....
   function () => (result:Type):
      ...
      result := expression;
   return;
create(parameters) => (@self: Object):
  ** class constructor
  if condition then
    let self := SuperType(some_arguments);
  else
    let self := SuperType(other_arguments);
  done;
  ...
return;
</code></pre>

<h3>Parameters</h3>

<p>A class can have parameters with an initial value. If you declare a type and inherit this type, parameters can be the same as for the super-type, but sometimes they are different. It is even possible to have a variable number of arguments, received as a HashMap for a vararg based constructor.</p>

<h4>Example:</h4>

<pre><code class="language-eve">
type BaseClass = {attributes} <: Object;

# define a class with constructor
class ClassName <: BaseClass;
  ** class body
  ...
create(parameters) => (@self:ClassName):
  ...
return;

process main:
  ** instantiate a local object using constructor
  new object := ClassName(param:value,...);
  ...
return;
</code></pre>

<p><b>Note:</b>The <em>object</em> in the previous example, has type: ClassName. So you can use the class name as type. The data type defined by the class is dynamicly created by the compiler using type inference.</p>

<h4>@self object</h4>

<p>Object named "self" is the current object name. This is the result of the class constructor. It uses prefix @ to show that it is a reference. The same name is used for declaring methods.</p>

<h2><a id="class-members"></a>Class members</h2>

<p>A class can define properties and functions. An object can have attributes and methods. Attributes are defined by the constructor. Properties and functions are defined inside the class declaration region.</p>

<h3>Properties</h3>

<p>A class is actually a <em>singleton object</em>. The class has public or private properties. Each property is defined in class context. Properties are static. We declare class properties after symbol ":"</p>

<ul>
<li>By default, class properties are public states;</li>
<li>Private class properties start with underscore "_"; 
<li>Properties are defined using keyword "set";
</ul>

<p>To access properties we can use class qualifier and dot notation:</p>

<pre class="output">class_name.class_property;</pre>

<h3><a id="functions">Functions</h2>

<p>You can define private or public functios for a class.  Most of the time you need only private functions. Functions have access to all properties and you do not have to use class qualifier to access them inside functions:</p>

<pre><code class="language-eve">
** call class functions
new result = ClassName.function(); 

** ignore function result
call ClassName.function(); 
</code></pre>

<h3>Attributes</h3>

<p>A class produce objects. Each object has public or private attributes. The class constructor must set initial values and define these attributes. Private attributes start with underscore (_). All other attributes are public and can be accessed using dot notation.</p>

<ul>
<li>We declare object attributes in "create" region;</li>
<li>Object attributes are define using keyword {"new", "let"};
</ul>

<p>To access attributes we can use dot notation:</p>

<pre class="output">object_name.object_attribute;</pre>

<p>We already know how to instantiate a class and create objects using a class. A class does not know anything about its objects. You can not ask the class anything about its instances, except if you create a special logic using class properties.</p>


<h2><a id="class-tree"></a>Class Tree</h2>

<p>Using the <em>"Object"</em> as the <em>"root"</em> Class you can create a hierarchy of classes. Each classes grows from Object or from other <em>"superclass"</em> forming a <em>"class tree"</em>. Like a real tree the class hierarchy has a single root.</p>

<div align="center">
   <img src="img/class-tree.svg" alt="Class Tree" width="680" class="img-fluid protect rounded shadow border" >
   <p>Class Tree</p>
</div>

<h4>Example:</h4>

<p>This example defines a "Point" class with two parameters. The parameters have default values so they are optional when you create a point. Read the example and the notes to understand how to use a user defined class constructor.</p>

<pre><code class="language-eve"># define a "Point" class
driver point_demo:

** type object
type Point = {x, y :Double} <: Object;

** type companion
class Point(x = 0, y = 0 :Double) => (@self: Object):

create
   let self := Object();

   ** set attribute values
   new self.x := x;
   new self.y := y;
return;

process main:
   ** initialize the points
   new p1 := Point(x:1, y:2);
   new p2 := Point(x:2, y:2);

   ** use string patterns to print attributes
   print "p1 = (a:#n, b:#n)" ? (p1.a,p1.b);
   print "p2 = (a:#n, b:#n)" ? (p2.a,p2.b);
return;
</code></pre>

<h4>Output:</h4>

<pre class="output">
p1 = {a:1, b:1}
p2 = {a:2, b:2}
</pre>

<h2><a id="comparing-objects"></a>Comparing objects</h2>

<p>We can use two comparison operators with objects: "is" and "==". First operator "is" will compare the object location. If the objects have the same location they represent the same object. Second operator: "==" compare object type and object attributes or value. There are complementar operators "is not" and "!=". That can be used to create conditionals.</p>

<h4>Example:</h4>

<p>In next examples we use a primitive type: Integer, that is actually a class. So any Integer number   is an Object.</p>

<pre><code class="language-eve">#object comparison demo
driver object_compare:
** global context variables
   set o = n = 1: Integer; 
process
   ** equal values and types
   expect   o   == n;
   expect   not (o != n);

   ** not the same location
   expect   not (o is n);
   expect   o is not n;

   ** alter one value
   let n := 2;

   ** equal values and types
   expect   o   != n;
   expect   not (o == n);
return;
</code></pre>


<h2><a id="inheritance"/>Inheritance</h2>

<p>Eve has support for inheritance. You can specify a supertype using the symbol "&lt;:" that is equivalent to the keyword: <em>"extend"</em> used in Java. Using this symbol makes a class that has all attributes and methods of the super-class or super-type.</p>

<h4>Pattern:</h4>

<pre><code class="language-eve"># define a class with inheritance
type BaseType: {attributes} <: Object;

** object method
method (@self:BaseType) demo(param:Type, ...):
   ....
return;

** create a descendent of BaseType
class ClassName <: BaseType
   ** class members
   ...
create(parameters) =>(@self: BaseType):
   ** call base class constructor
   let self := {attributes};
   ...
return;

** overwriten method
method (@self:ClassName) demo(parameters) => (result:Type):
   ...
return;
</code></pre>
<hr>



<p><b>Read next:</b>
<a href="functions.html">Functions</a></p>

<!-- Footer -->
<footer class="footer">
   <div class="footer-copyright text-center"></div>
</footer>
</div>
</body>
</html>