<html><head>
  <meta charset="utf-8">
  <meta name="description" content="Sage-Code Eve object oriented programming. Classes and Objects. ">
  <meta name="author" content="Elucian Moise">
  <meta name="keywords" content="SageCode, EVE, EveLang, programming, language, specification">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Website title -->
  <title>Eve OOP</title>

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
  <!-- Icon -->
  <link rel="icon" type="image/png"  href="../images/favicon.ico">
  <!-- Eve code highlighter -->
  <script src="eve.js"></script>
  <!-- Sage-Code custom CSS -->
  <link rel="stylesheet" href="../sage.css">
  </head>
<body onload="eve_render();">

<div class="container">

<!-- header -->
<div class="row">
    <div class="col">
        <a href="https://sagecode.net"><img src="../images/sage-logo.svg" alt="Sage-Code Laboratory" height="80"/></a>
    </div>
    <div class="col  bottom-right">
        <a href="index.html#lang-index">index</a><--
    </div>
</div><hr>

<h1>Eve Classes</h1>

<div class="alert alert-secondary shadow-sm">
Eve is an object oriented language, so we need Classes. Eve classes are very similar to Java classes. A class is a companion for an user-defined data type. It implements behaviour for data. Classes are called to instantiate Objects and set the Object attributes.</div>

<h2>Eve Classes</h2>

<p>Objects are&nbsp;<em>state machines</em>&nbsp;that are instantiated on demand and released from memory when they are no longer needed. You can create global objects using "set" and local objects using "new".</p>

<p>The most important characteristics of objects are:</p>

<ul>
<li>Encapsulation: each object has its own states;</li>
<li>Inheritance: an object inherit its base class;</li>
<li>Polymorphic: an object can play its base class role;</li>
</ul>

<div class="alert alert-info"><b>Note:</b> Objects can't be abstract but you can define an abstract constructor that can be extended. So Eve implements actually all 4 OOP principles.</div>

<h4>Bookmarks:</h4>
<ul>
<li><a href="#object">object instances</a></li>
<li><a href="#companion">type companion</a></li>
<li><a href="#instances">class instances</a></li>
<li><a href="#attributes">attributes</a></li>
<li><a href="#inheritance">inheritance</a></li>
</ul>

<h2><a id="object"></a>Object Instances</h2>

<p>Objects are variables that need to be initialized using a Class. The most simple object is an instance of type Object. The Object is the fundamental class in EVE, that is why it starts with uppercase.</p>

<h4>Pattern:</h4>

<p>Initialize an object by using an object literal with initialization values:</p>

<pre><code class="language-eve">
# define global object instances
driver test:
    ** empty object
    set object_name1: Onject(); 

    ** object with attributes
    set object_name2: {attribute:value, ...} <:Object;
 return;
</code></pre>

<p><b>Notes:</b>An object is a reference to a data structure that is created by using the default constructor. This receive a list of attribute-value pairs: {attribute:value, ...}. The default constructor accept a list of parameters (attribute:value,.)</p>


<h4>Alternative:</h4>

<p>Initialize an object by using an explicit constructor call.</p>

<pre><code class="language-eve">#define an object instance
process test:
  ** initialize object using Object() constructor
  new object_name := Object(attribute1:value1, 
                            attribute2:value2, ...);
  ...
return;
</code></pre>

<p><b>Note:&nbsp;</b>One object instance can receive attribute names that do not exist and bind values to them using column ":" symbol. Default constructor will create new attributes automatic and set-up an implicit data type using type inference. This is possible due to gradual typing algorithm.</p>

<h2><a id="companion"></a>Type companion</h2>

<p>You can create more complex objects by using a type companion. This start with keyword "class". This is a special subroutine that can create object instances. The object name that is going to be created is an implicit output result, that is called "@self" that must be explicit declared as a result of a class.</p>

<h4>Pattern:</h4>

<p>First you define a type then a "class" with the same name. That is named a companion. The companion has a local static scope. You can define things anywehre. Unlike processes it does not have a "recover" region but it has a "remove" region.</p>

<pre><code class="language-eve">
# user defined type  
type TypeName = {} <: SuperType;

# type companion (same name)
class TypeName(parameters) => (@self :TypeName):
  ** properties
  ...
  ** methods
  ...  
create
  ** attributes
  ...   
release
  ** cleanup
  ...
return;
</code></pre>

<p><b>Notes:&nbsp;</b>A class can have role of a object constructor or type companion. In fact, a class is a "high order function" with closures: We name closure "methods" in Eve.</p>

<h3>Constructor</h3>

<p>The @self object represents the result of a class. In "create" region we can use decision statements to create the &nbsp;<em>"object"</em>&nbsp; attributes in different ways based on conditions.</p>

<h4>Pattern:</h4>

<pre><code class="language-eve">...
class name(parameters) => (@self: Object):
  ** declarations
  ....
create
  ** conditional construction
  if condition then
      let self := SuperType(some_arguments);
  else
      let self := SuperType(other_arguments);
  done;
  ...
return;
</code></pre>

<h3>Parameters</h3>

<p>A class can have parameters with initial value. If you declare a type, parameters can be the same as for the type, but sometimes they are different.</p>

<h4>Example:</h4>

<pre><code class="language-eve"># define a class with prameters
class ClassName(parameters) => (@self:ClassName):
    ** class body
    ....
create
    ....
return;

process main:
    ** macking a constructor call
    new object := ClassName(param:value,...);
    ...
return;
</code></pre>

<p>The <em>object</em> from previous example, is created using a <em>class</em>: ClassName. This do not have a type so is not a companion but a constructor. For this, an implicit type will be created automaticly.</p>

<h4>@self object</h4>

<p>Object named "self" is the current object name, reserved by EVE. This is either the result of a companion or a parameter in a method. It uses prefix @ to show that is a reference.</p>

<p>@self object must be initialized as quickly as possible inside the constructor. In Java, we call current object "this". Eve is more like Python.</p>

<pre class="output">
class ClassName(parameters) => (@self:ClassName):
   ...
return;
</pre>

<h4>Note:</h4>
<ul>
<li>In Java you must use "new" or "set" to create an object;</li>
<li>In Eve you can use ":=" with JSON to create an object.</li>
</ul>

<h2><a id="attributes"></a>Attributes</h2>

<p>A class can have object attributes and class properties. Attributes represent states of an object wile properties are class states. Try to remember this convention to understend better Eve design.</p>

<ul>
<li>We declare properties and attributes after symbol ":"</li>
<li>Public properties are defined using (.) prefix with "set" keyword.</li>
<li>Attributes are define using keyword "new" or "let";
<li>Private attributes start with underscore "_"; 
</ul>

<h3>Object attributes</h3>

<p>To access attributes we can use dot notation:</p>

<pre class="output">object_name.object_attribute;</pre>

<p>We already know how to instantiate a class and create objects using a type companion. After you have defined a class, this do not know anything about it's objects. You can not ask the class anything about it's instances.</p>

<h3>Class attributes</h3>

<p>For a class, you can define static attributes and methods. That's the secret: a class is actually a <em>singleton object</em>. The class is holding the <em>class states</em>. Each attributes defined in class context using keyword "set". Unlike "let" or "new" that create the attributes of object, "set" create properties for the class singleton.</p>

<p>You can access all static members without instantiation of the class. But you can also access class members using the object qualifier. Both will point to the same <em>class states</em> also called </em>class attributes</em>.</p>

<pre class="language-eve">** accessing static attributes
ClassName.class_attribute;   -- using the class name
object_name.class_attribute; -- using the object name
</pre>

<h4>Class Tree</h4>

<p>Using the <em>"Object"</em> as the <em>"root"</em> Class you can create a hierarchy of classes. Each classes grows from Object or from other <em>"super class"</em> forming a <em>"class tree"</em>. Like a real tree the class hyerarchy has a single root.</p>

<div align="center">
  <img src="img/class-tree.svg" alt="Class Tree" width="680" class="img-fluid protect rounded shadow border" >
  <p>Class Tree</p>
</div>

<h4>Example:</h4>

<p>This example define a "Point" class with two parameters. The parameters have default values so they are optional when you create a point. Read the example and the notes to undestend how to use a user defined class constructor.</p>

<pre><code class="language-eve"># define a "Point" class
driver point_demo:

** type object
type Point = {x, y :Double} <: Object;

** type companion
class Point(x = 0, y = 0 :Double) => (@self: Object):
  let self := Object();

  ** set attribute values
  let self += {'x': x};
  let self += {'y': y};
return;

process main:
  ** initialize the points
  new p1 := Point(x:1, y:2);
  new p2 := Point(x:2, y:2);

  ** use string patterns to print attributes
  print "p1 = (a:#n, b:#n)" ? (p1.a,p1.b);
  print "p2 = (a:#n, b:#n)" ? (p2.a,p2.b);
return;
</code></pre>

<h4>Output:</h4>

<pre class="language-output">
p1 = {a:1, b:1}
p2 = {a:2, b:2}
</pre>

<h2><a id="comparing-objects"></a>Comparing objects</h2>

<p>We can use two comparison operators with objects: "is" and "==". First operator "is" will compare the object location. If the objects have same location they represent the same object. Second operator: "==" compare object type and object attributes or value. There are complementar operators "is not" and "!=". That can be used to create conditionals.</p>

<h4>Example:</h4>

<p>In next examples we use a primitive type: Integer, that is actually a class. So any number of type Integer is an object.</p>

<pre><code class="language-eve">#object comparison demo
driver object_compare:
** global context variables
  set o = n = 1: Integer; 
process
  ** equal values and types
  expect  o  == n;
  expect  not (o != n);

  ** not the same location
  expect  not (o is n);
  expect  o is not n;

  ** alter one value
  n := 2;

  ** equal values and types
  expect  o  != n;
  expect  not (o == n);
return;
</code></pre>

<h2><a id="inheritance"/>Inheritance</h2>

<p>Eve has support for inheritance. You can specify a superclass using symbol "&lt;:" that is equivalent of keyword: <em>"extend"</em> used in Java. Using this symbol makes a class that has all attributes and methods of the super-class.</p>

<h4>Pattern:</h4>

<pre><code class="language-eve"># define a class with inheritance
type BaseType: {attributes} <: Object;

class BaseType(parameters) => (@self:Object):
   ...
   * object method
   method demo(@self:BaseType,...):
      ....
   return;
return;

** create a descendent of BaseType
class ClassName(parameters) &lt;: BaseType:
  ** class members
  ...
  ** call base class constructor
  self := base_class(object_attribute:argument,...);
  ...
  ** overwriten method
  method demo(@self:BaseType,...) => (result:Type):
    ...
  return;
return;
</code></pre>

<h2><a id="methods"></a>Methods</h2>

<p>Methods can be defined inside of a class. The methods can have parameters and can return results. Also if a method receive @self argument, this is an input-output argument representing the object instance.</p>

<h4>Example</h4>

<pre><code class="language-eve"># define a "Point" class
driver point_demo:
type 
  Point = {x, y :Double} <: Object; 

class Point(x = 0, y = 0 :Double) => (@self: Object):
  let self := {'x': x,'y': y};

  method move(@self, a, b: Double):
    let self.x += a;
    let self.y += b;
  return;

  method string(@self) => (string:String):
     let string := "# = (#:#)" ? (@self).id, self.a, self.b);
  return;
return;

process main:
  ** initialize the points
  new p := Point(x:1, y:2);

  ** move the point
  apply p.move(2,1);
  print p.string(); -- (3:3)

return;
</code></pre>

<hr>
<p><b>Read next:</b>
<a href="functions.html">Functions</a></p>

<!-- Footer -->
<footer class="footer">
  <div class="footer-copyright text-center"></div>
</footer>
</div>
</body>
</html>