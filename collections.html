<html><head>
  <meta charset="utf-8">
  <meta name="description" content="Sage-Code Eve programming, collections explained.">
  <meta name="author" content="Elucian Moise">
  <meta name="keywords" content="sagecode, EVE, EveLang, collections, programming">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Website title -->
  <title>Eve Collections</title>

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
  <!-- Icon -->
  <link rel="icon" type="image/png"  href="../images/favicon.ico">
  <!-- Eve code highlighter -->
  <script src="eve.js"></script>
  <!-- Sage-Code custom CSS -->
  <link rel="stylesheet" href="../sage.css">
  </head>
<body onload="eve_render();">

<div class="container">

<!-- header -->
<div class="row">
    <div class="col">
        <a href="https://sagecode.net"><img src="../images/sage-logo.svg" alt="Sage-Code Laboratory" height="80"/></a>
    </div>
    <div class="col  bottom-right">
        <a href="index.html#lang-index">index</a><--
    </div>
</div><hr>

<h1>Eve Collections</h1>

<div class="alert alert-secondary shadow-sm">
Collections are composite types represents groups of elements of the same type. In Eve collections are actually generics. Usually we declare collections using "gradual typing" technique but it is possible to use an explicit declaration. </div>

<h4>Bookmarks:</h4>

<ul>
<li><a href="#ordinal">Ordinal</a></li>
<li><a href="#list">List</a></li>
<li><a href="#dataset">DataSet</a></li>
<li><a href="#table">Table</a></li>
<li><a href="#string">String</a></li>
<li><a href="#text">Text</a></li>
<li><a href="#exception">Exception</a></li>
</ul>

<h2><a id="ordinal"</a>Ordinal</h2>

<p>Ordinal is an generic class representing a set of unique ordered symbols. Each symbol represents an integer value starting from N to capacity C. Element values start with 1 or a specific number and grow with one for each element.</p>

<h4>Pattern:</h4>
<pre><code class="language-eve"># Define a Ordinal subtype
driver test_ordinal;  
  type TypeName = {name1:0, name2, name3} &lt;: Ordinal;
process main:
  new a := TypeName.name1; -- a=2
  new b := TypeName.name2; -- b=3
  new c := TypeName.name3; -- c=4
return;
</code></pre>

<p><b>Note:</b>&nbsp;When element name start with capital letter no need to use qualifiers for the individual values. This is because values starting with capital letters are public constants by default and known in the scope where ordinal is visible.</p>

<pre><code class="language-eve">## Declare public elements in enumeration
driver constant_ordinals;
  type TypeName = {Name1:10, Name2} &lt;: Ordinal;
process main:
  new a := Name1; -- a = 10
  new b := Name2; -- b = 11
  ** verify values
  expect a == 10;
  expect b == 11;
return;
</code></pre>

<h2><a id="list" class="anchor" href="EVE#list"></a>List</h2>
<p>A list is a consecutive sequence of elements having a dynamic capacity. Elements are ordered in the order you create them. The order can change if you sort the list or add/remove elements.</p>

<h4>Syntax:</h4>
<pre><code class="language-eve">#declare two lists
** empty list
  new list1 := ();  

** type inference
  new list2 := (value1, value2, ...); 

** using constructor
  new list3 := List(value1,value2,...)
</code></pre>

<h4>Notes:</h4>
<ul>
<li>The elements of a list have the same type;</li>
<li>Access to all or each element is sequential;</li>
</ul>

<h4>Examples:</h4>

<pre><code class="language-eve">
# gradual declaration
  new e_list :List;

# explicit declarations
  new n_list :()Integer;
  new o_list :()Object ; 
  new s_list :()String ; 
  new u_list :()Unicode; 
</code></pre>

<p><b>list literals</b></p>
<ul>
<li>List literals enclosed in square brackets,</li>
<li>Elements are separated by comma,</li>
<li>All elements are having the same type.</li>
</ul>

<h4>Examples:</h4>
<p>Literals can be used for initialization of variables:</p>
<pre><code class="language-eve"># initialized list with type inference
    new c_list := ('a', 'b', 'c');
    new n_list := (1, 2, 3);
</code></pre>

<p>Literals can be used in assign expressions:</p>
<pre><code class="language-eve"># Defer initialization
driver begin_initial:
    ** define empty list
    set c_list: List;
process main:
    ** initialize the list
    let c_list := (1,2,3);
return;
</code></pre>

<h2><a id="dataset"/>DataSet</h2>

<p>In mathematics a data set is an abstract data structure that can store certain values, in random order, but has no repeated values. Sets are fast collections for search, add update with new values. However, you have to know the element <em>value</em> in order to search for it.</p>

<h4>Empty DataSet</h4>

<p>An empty DataSet is represented like this: {} and can be assigned to a set if you wish to remove all elements of the set. A set that is not initialized is Null.</p>

<pre><code class="language-eve">
** Define empty DataSet but not Null
set e_name = {}; 

** Define a Null DataSet
set n_name :DataSet;

** Define DataSet with element type
set t_name : {}Integer;
</code></pre>


<h4>Set restrictions</h4>
<ul>
<li>All elements of a set must have the same type</li>
<li>Set elements can have only comparable types: {Numeric, String, Ordinal, Unicode}. You can't create a set of objects.</li>
</ul>

<h4>Mutability</h4>
<p>A set can be modified during run-time using operators. When you modify a set, keep in mind that set's are automaticly sorted by a hash key.</p>

<p> You never know what the position of the new element is going to be. Also if you add or remove an element the position of several other elements will be shifted.</p>

<ul>
<li>new, += for append</li>
<li>del, -= for delete</li>
</ul>

<p><b>Note: </b>Any modifier "x=" can be used for altering individual elements. You can rever to all elements using "*" and modify them.</p>

<h4>Example:</h4>
<pre><code class="language-eve">#demo for using a set
driver set_demo:

** initialized DataSet of integers
  set my_set = {0,2,3} :DataSet;
process main:
  ** append element 1
  let my_set += 1;
  expect my_set == {0,1,2,3};

  ** remove element 2
  let my_set -= 2;
  expect my_set == {0,1,3};

  ** modify all elements
  let my_set[*] := 0;
  expect my_set == {0,0,0};

  ** remove all elements
  let my_set := {};
  expect my_set == {};
return;
</code></pre>

<h3>Union</h3>

<p>Use union operator to combine two sets.</p>
<pre><code class="language-eve"># combine two sets using "|" = (or)
driver set_union_demo:
* 10 element set
  set first = {0,1,2,3};
  set second: DataSet; -- Null DataSet
process
  ** asign elements using union
  let second := first | {2, 4, 8, 10};

  ** element "2" was common 
  expect second == {0,1,2,3,4,8,10};
return;
</code></pre>

<h3>Intersection</h3>

<p>Intersect operator &amp; find common elements:</p>

<pre><code class="language-eve"># Create intersection using &amp;
driver set_intersection_demo:
  set test: DataSet; -- Null set
process main:
  let test := {1,2,3,4} &amp; {3,4,5};
  expect test == {3,4};
return;
</code></pre>

<h2><a id="table"></a>Table</h2>

<p>It is also called "hash-table" in other language due to similar letter H representing a connection between two columns. Collections are ordered by keys. This helps to find elements faster using a binary search.</p>

<ul>
<li>Tables are sets of (key:value) pairs;</li>
<li>The key must be sortable: { Number, String, Ordinal};</li>
<li>Value can be anything including objects.</li>
</ul>

<h4>Syntax:</h4>
<pre><code class="language-eve">
type Dic = {}(String, Object) <: Table;
driver test:
# Null map
  set m :Dic;
process main:
  expect type(m) == Table
  expect m is Null;
  expect m == {};
return;
</code></pre>

<h4>Example:</h4>
<pre><code class="language-eve">
# how to initialize a table
driver table_init:
    set t: Table;
process main:
    ** initialize table
    let t := {'one':1, 'two':2};

    ** accessing elements
    expect t['one'] == 1;
    expect t['two'] == 2;
return;
</code></pre>

<h2><a id="string"></a>String</h2>

<p>In Eve, we have two types of strings. Single quoted and double quoted. Single quoted strings are ASCII encoded while double quoted string are Unicode. Single quoted strings has a limited capacity. Double quoted strings can store multiple lines of text and it has variable capacity.</p>

<ul>
<li>Single quoted string, has default capacity 1024 bytes;</li>
<li>Double quote strings have unrestricted capacity;</li>
</ul>

<h3>String declaration</h3>

<p>String can be initialized with a constant literal using single quotes or double quotes. It is possible to do a conversion between the wrong literal and the right string type but the encoding change and in the end the two will be distinct objects.</p>

<h4>Syntax:</h4>
<pre><code class="language-eve">
** define Null string with default capacity
new strName :String;   

** define string with specific capacity
new lmString:String(capacity);  

** define a unlimite capacity Unicode
new text :Unicode; 

** define limited capacity Unicode
new text :Unicode(capacity);
</code></pre>

<h4>Initialization:</h4>

<p>In next examples we use type inference to set strings. ASCII strings can have a large capacity but onlu a part is initialized. All remaining characters are Null.</p>

<pre><code class="language-eve">
# examples of empty strings
new short_string := ''*100;  -- this string can hold 100 symbols
new default_str  := '';      -- default capacity 1024 ASCII Null
new unicode_str  := "";      -- variable capacity Unicode string
new unicode_str  := ""*100;  -- a short capacity Unicode string

# examples of initial values
new long_line := '-'*80      -- a long line of 80 ASCII characters
new dash_dot  := "-&middot;" -- a long line -&midot;-&midot;-&midot;
</code></pre>

<h3><a id="string-mutability"></a>String mutability</h3>

<p>In Eve Strings are mutable. If you use ":=" the string object is replaced. If you use modifiers:"&lt;+" the double quoted string can be resized. For single quoted strings, if the capacity is over the limit you will get an error: "string capacity overflow".</p>

<h4>Example:</h4>

<pre><code class="language-eve"># working with strings
driver test_string:
  ** shared mutable strings
  set str := 'First value';
  set ref := 'First value';
process
  ** check initial value
  expect str == ref;     --  same value
  expect str eq ref;     --  same value and type
  expect str is not ref; --  different locations

  ** operator ":=" works by reference
  ref := str;        --  reset ref
  expect str == ref; --  same value
  expect str is ref; --  same reference

  ** if we modify "str" then "ref" will appear modified
  let str &lt;+ ":"; --  mutate string "str"
  expect str == 'First value:'; --  modified
  expect ref == "First value:"; --  also modified
  expect str is ref; -- the reference is holding

  ** if we recreate str, reference is reset
  let str := 'First value:'; --  new string
  expect str == ref;     --  same value
  expect str is not ref; --  different location

  ** ref is pointing to a different location
  let ref  := 'New value:'
  print ref;  --  New value: (modified)
  print str;  --  First value: (initial value)
return;
</code></pre>

<p><b>Note:</b></p>
<ul>
<li>You can create garbage in Eve if you loose references;</li>
<li>Provision for large capacity strings is not recommended;</li>
</ul>

<h3><a id="string-comparison"></a>String comparison</h3>
<ul>
<li>Two strings are compared using relation operators: { ==, !=, &lt;, &gt;, &gt;=, &lt;= };</li>
<li>Two strings that have identical characters are equivalent regardless of quotation;</li>
<li>The length of the string is the number of symbols:</li>
<li>Empty string '' has length 0 other strings have length>0;</li>
<li>String capacity >= string length, at all times.</li>
</ul>

<h4>Example:</h4>
<pre><code class="language-eve"># compare strings
driver compare_strings:
    expect('this' == 'this');   --  true (same value)
    expect("this" == 'this');   --  true (same value)
    expect(' this' != 'this');  --  true (not same value)
    expect("this " != "this");  --  true (not same value)
return;
</code></pre>

<h3><a id="null-strings"></a>Null strings</h3>
<p>We can test if a string is Null using "is Null" expression.</p>
<pre><code class="language-eve"># null string demo
driver null_string:
  ** Null strings
  set str :String; 
  set btr := 'x';   
process
    ** null string
    expect str == Null;
    expect str == '';
    expect str == "";

    ** initialized string
    expect btr is not Null;
    expect btr == "x";
    expect btr == 'x';
return;
</code></pre>

<h2><a id="unicode"></a>Unicode</h2>
<p>Unicode strings can contain multiple lines separated with end of line character. Unicode strings use Unicode symbols and are optimized for faster search.</p>

<h4>Literal</h4>

<p>Unicode literal can be defined on multiple lines and will preserve the end of line but will cut the indentation. Unicode literal is enclosed in double quotes. "..." and it may contain symbol "'" without escape. Double quoted Symbol (") must be escaped using notation (\").</p>

<pre><code class="language-eve"># declaration of a text literal
driver text_literal:
  set Text my_text;
process main:
  my_text:="""
    Opportunity is missed by most people if
    process
    because it is dressed in overalls case
    and process looks like work.
    """; -- test

  process /* test if end */ else
  print
  print (my_text);
  
  test:= " unu" == "doi" == "trey \" patru", "cini'ci";
  test:= " unu" == "doi" == "trey \" patru", "cinici";

  test:= ' unu\" ' == 'doi' = 'trei\"patru'
return;
</code></pre>

<p><b>Output:</b></p>
<pre class="output">
Opportunity is missed by most people
because it is dressed in overalls
and looks like work.
</pre>

<p><b>Unicode</b></p>
<p>The&nbsp;<em>Unicode</em>&nbsp;is a standard for representation of writing for all human languages. An Unicode string is a set of&nbsp;<em>code points</em>&nbsp;using symbols from universal character set (UCS). Unicode is more difficult to represent then ASCII. There are many encoding techniques available. Java uses UTF-16. We will probably use UTF-8 to be more efficient.</p>

<p>See also:&nbsp;<a href="https://en.wikipedia.org/wiki/Universal_Coded_Character_Set" rel="nofollow">wikipedia ucs</a>,&nbsp;<a href="https://en.wikipedia.org/wiki/List_of_Unicode_characters#Character_reference_overview" rel="nofollow">unicode characters</a></p>

<h4>Example:</h4>
<pre><code class="language-eve"># text type has unicode support
driver unicode_text:
    Text us = "I can write Greek: \&alpha;&beta;&gamma;&delta;\.";
process
    print us;
return;
</code></pre>

<h4>Output:</h4>

<pre class="language-eve">I can write Greek: "&alpha;&beta;&gamma;&delta;".</pre>

<p>To edit source code containing Unicode literals one must use a specific font and UTF-8 source files. The preferred font for Eve programming is "DejaVu Sans Mono".</p>


<h2><a id="exception" class="anchor" href="EVE#exception"></a>Exception</h2>
<p>Exception is interrupting the current logical flow and jump to the recover region in current section or parent section. In Eve all exceptions are considered errors.</p>
<p>The exception is a variable of type Object that is created when exception is raised and is available in the recover block. System variable $error contains several members that are fill-in by the Eve program when exception is created:</p>
<pre><code class="language-eve">** system exception type
Class .Exception <: Object {
    Integer code
   ,String  message
   ,String  routine_name
   ,String  module_name
   ,String  line_number
};

** system variables for last error is predefined
global Exception: $error;
</code></pre>
<h3><a id="run-time-errors"></a>Run-time errors</h3>

<p>Exceptions can be system exceptions or user defined exceptions.</p>
<p><b>system exception</b>&nbsp;System exceptions are predefined and created during the program execution when there is a&nbsp;<em>"run-time error"</em>&nbsp;and program can not continue.</p>
<h3><a id="user-defined-exceptions" class="anchor" href="EVE#user-defined-exceptions"></a>User defined exceptions</h3>
<p>There are two alternative statements to create user defined exceptions.</p>

<pre><code class="language-eve">** create exception
fail (code,"message") if condition;
</code></pre>

<h3><a id="exception-handling"></a>Exception handling</h3>
<p>Recover: region define an "exception handling region" for a routine.</p>
<p>In this region developer can use control statements like "switch","case" to analyze the #Error. Developer can decide to stop the program, print a message and resume the program using&nbsp;<em>resume</em>&nbsp;keyword.</p>
<h4>Example:</h4>
<pre><code class="language-eve">#using recover
driver recover_demo:

global
    Double a = 0.00;

process
    a := 1/0;
recover
    print $error.message;
return;
</code></pre>

<h4>Output:</h4>

<pre class="output">error: numeric division by zero.</pre>

<h3>Using expect</h3>

<p>The expect statement check a condition and raise an error if condition is false. Error message is default: "Unexpected error in line: N".</p>

<h4>Pattern:</h4>

<pre><code class="language-eve">** precondition (short version)
expect condition;

** equivalent (longer version)
fail "Unexpected error in line \n"
      ? $error.line_number if condition;
</code></pre>

<h4>Nots:</h4>
<ul>
<li>can be used as pre-condition</li>
<li>can be used as post-condition</li>
<li>unexpected error has code = 0</li>
</ul>

<!-- work in progress-->

<hr>
<p><b>Read next:</b>
<a href="control.html">Control Flow</a></p>

<!-- Footer -->
<footer class="footer">
  <div class="footer-copyright text-center"></div>
</footer>
</div>
</body>
</html>